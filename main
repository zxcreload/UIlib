-- Load the Obsidian UI Library and addons
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

-- Create tabs
local Tabs = {
    Combat = Window:AddTab("Combat", "sword"),
    Movement = Window:AddTab("Movement", "move"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Misc = Window:AddTab("Misc", "box"),
    Other = Window:AddTab("Other", "list"),
    HUD = Window:AddTab("HUD", "monitor"),
}

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")

-- Local variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

-- Aimbot configuration
getgenv().AimSettings = {
    AimPart = "Head",
    FOV = 300,
    FOVVisible = false,
    FOVType = "Outline",
    TeamCheck = false,
    PredictMovement = false,
    Smoothness = 0.15,
    predictionXZ = 0.4,
    predictionY = 0.2,
    WallCheck = false,
    RagdollCheck = false,
    ResolverMode = "Velocity",
    Enabled = false,
    AimlockKey = "E"
}

-- Triggerbot Settings
getgenv().TriggerbotSettings = {
    Enabled = false,
    Delay = 0.1,
    Radius = 100,
    CircleVisible = false,
    CircleType = "Outline",
    Mode = "Always",
    Keybind = "T",
    ToggleState = false,
    TargetMode = "Center of Screen"
}

-- Aimbot UI elements
local AimbotGroup = Tabs["Combat"]:AddLeftGroupbox("Aimbot Settings")
local AimToggle = AimbotGroup:AddToggle("AimEnabled", {
    Text = "Enable Aimbot",
    Default = getgenv().AimSettings.Enabled,
    Tooltip = "Enable/Disable the aimbot",
    Callback = function(Value)
        getgenv().AimSettings.Enabled = Value
    end
})

local AimKeybind = AimToggle:AddKeyPicker("AimKeybind", {
    Default = getgenv().AimSettings.AimlockKey,
    Mode = "Toggle",
    Text = "Aim Key",
    NoUI = false,
    Callback = function(Value) end,
    ChangedCallback = function(NewKey)
        getgenv().AimSettings.AimlockKey = tostring(NewKey):lower()
    end
})

AimbotGroup:AddDropdown("AimPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = getgenv().AimSettings.AimPart,
    Multi = false,
    Text = "Aim Part",
    Tooltip = "Select the part to aim at",
    Callback = function(Value)
        getgenv().AimSettings.AimPart = Value
    end
})

AimbotGroup:AddSlider("FOVSize", {
    Text = "FOV Size",
    Default = getgenv().AimSettings.FOV,
    Min = 50,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        getgenv().AimSettings.FOV = Value
    end
})

AimbotGroup:AddToggle("FOVVisible", {
    Text = "Show FOV",
    Default = getgenv().AimSettings.FOVVisible,
    Tooltip = "Show/Hide the FOV circle",
    Callback = function(Value)
        getgenv().AimSettings.FOVVisible = Value
    end
})

AimbotGroup:AddDropdown("FOVType", {
    Values = {"Outline", "Filled"},
    Default = getgenv().AimSettings.FOVType,
    Multi = false,
    Text = "FOV Type",
    Tooltip = "Select FOV display type",
    Callback = function(Value)
        getgenv().AimSettings.FOVType = Value
    end
})

AimbotGroup:AddToggle("TeamCheck", {
    Text = "Team Check",
    Default = getgenv().AimSettings.TeamCheck,
    Tooltip = "Ignore teammates",
    Callback = function(Value)
        getgenv().AimSettings.TeamCheck = Value
    end
})

AimbotGroup:AddToggle("PredictMovement", {
    Text = "Predict Movement",
    Default = getgenv().AimSettings.PredictMovement,
    Tooltip = "Predict target movement",
    Callback = function(Value)
        getgenv().AimSettings.PredictMovement = Value
    end
})

AimbotGroup:AddSlider("PredictionXZ", {
    Text = "Horizontal Prediction",
    Default = getgenv().AimSettings.predictionXZ * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.predictionXZ = Value / 100
    end
})

AimbotGroup:AddSlider("PredictionY", {
    Text = "Vertical Prediction",
    Default = getgenv().AimSettings.predictionY * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.predictionY = Value / 100
    end
})

AimbotGroup:AddSlider("Smoothness", {
    Text = "Smoothness",
    Default = getgenv().AimSettings.Smoothness * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.Smoothness = Value / 100
    end
})

AimbotGroup:AddDropdown("ResolverMode", {
    Values = {"Velocity", "Move direction", "Calculate CFrame"},
    Default = getgenv().AimSettings.ResolverMode,
    Multi = false,
    Text = "Resolver Mode",
    Tooltip = "Select prediction calculation mode",
    Callback = function(Value)
        getgenv().AimSettings.ResolverMode = Value
    end
})

AimbotGroup:AddToggle("WallCheck", {
    Text = "Wall Check",
    Default = false,
    Tooltip = "Ignore targets behind walls",
    Callback = function(Value)
        getgenv().AimSettings.WallCheck = Value
    end
})

AimbotGroup:AddToggle("RagdollCheck", {
    Text = "Ragdoll Check",
    Default = false,
    Tooltip = "Ignore ragdolled/dead targets",
    Callback = function(Value)
        getgenv().AimSettings.RagdollCheck = Value
    end
})

-- Замените существующую функцию IsTargetVisible на эту
local function IsTargetVisible(targetPart)
    if not getgenv().AimSettings.WallCheck then return true end
    
    local origin = Camera.CFrame.Position
    local targetPos = targetPart.Position
    local direction = (targetPos - origin)
    local distance = direction.Magnitude
    
    -- Настраиваем параметры raycast
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    -- Выполняем raycast
    local result = Workspace:Raycast(origin, direction, params)
    
    if result then
        local hitPart = result.Instance
        -- Проверяем, попали ли мы в часть персонажа цели
        local targetCharacter = targetPart:FindFirstAncestorOfClass("Model")
        local hitCharacter = hitPart:FindFirstAncestorOfClass("Model")
        
        -- Если попали не в персонажа цели, значит есть стена
        if hitCharacter ~= targetCharacter then
            return false
        end
    end
    
    return true
end

-- Также обновим функцию FindTarget для лучшей совместимости
local function FindTarget()
    if not getgenv().AimSettings.Enabled then return nil end
    
    local closestPlayer, closestDistance = nil, math.huge
    local fovRadius = getgenv().AimSettings.FOV / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if getgenv().AimSettings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        
        if not IsTargetValid(character) then continue end
        
        local aimPart = character:FindFirstChild(getgenv().AimSettings.AimPart)
        if not aimPart then continue end
        
        -- Сначала проверяем FOV, затем видимость через стены
        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPart.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance <= fovRadius and distance < closestDistance then
            if IsTargetVisible(aimPart) then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end
    
    return closestPlayer
end

local function IsTargetValid(targetCharacter)
    if not getgenv().AimSettings.RagdollCheck then return true end
    
    local humanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    if humanoid.Health <= 0 then return false end
    
    local states = {
        Enum.HumanoidStateType.FallingDown,
        Enum.HumanoidStateType.Physics,
        Enum.HumanoidStateType.Dead
    }
    
    for _, state in ipairs(states) do
        if humanoid:GetState() == state then
            return false
        end
    end
    
    local rootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if rootPart then
        local characterHeight = targetCharacter:GetExtentsSize().Y
        if rootPart.Position.Y < (characterHeight * 0.5) then
            return false
        end
    end
    
    return true
end

local function FindTarget()
    if not getgenv().AimSettings.Enabled then return nil end
    
    local closestPlayer, closestDistance = nil, math.huge
    local fovRadius = getgenv().AimSettings.FOV / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if getgenv().AimSettings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        
        if not IsTargetValid(character) then continue end
        
        local aimPart = character:FindFirstChild(getgenv().AimSettings.AimPart)
        if not aimPart then continue end
        
        if not IsTargetVisible(aimPart) then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPart.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance <= fovRadius and distance < closestDistance then
            closestDistance = distance
            closestPlayer = player
        end
    end
    
    return closestPlayer
end

local LastPosition, LastTick, PredictedPosition
local function PredictPosition(target)
    if not (target and target.Character) then return nil end
    
    local aimPart = target.Character:FindFirstChild(getgenv().AimSettings.AimPart)
    if not aimPart then return nil end
    
    local currentPos = aimPart.Position
    
    if not (LastPosition and LastTick) then
        LastPosition = currentPos
        LastTick = tick()
        return currentPos
    end
    
    local currentTick = tick()
    local deltaTime = currentTick - LastTick
    
    if getgenv().AimSettings.ResolverMode == "Velocity" then
        local velocity = aimPart.Velocity
        PredictedPosition = currentPos + Vector3.new(
            velocity.X * getgenv().AimSettings.predictionXZ,
            velocity.Y * getgenv().AimSettings.predictionY,
            velocity.Z * getgenv().AimSettings.predictionXZ
        )
    elseif getgenv().AimSettings.ResolverMode == "Move direction" then
        local moveDir = target.Character.Humanoid.MoveDirection
        PredictedPosition = currentPos + (moveDir * (getgenv().AimSettings.predictionXZ * 10))
    else -- "Calculate CFrame"
        if (currentPos - LastPosition).Magnitude < 0.001 then
            PredictedPosition = currentPos
        else
            local distance = (currentPos - LastPosition).Magnitude
            local speed = (distance / deltaTime) * (0.1 * (getgenv().AimSettings.predictionXZ * 10))
            PredictedPosition = currentPos + (currentPos - LastPosition).Unit * speed
            local verticalSpeed = (currentPos.Y - LastPosition.Y) / deltaTime * (0.1 * getgenv().AimSettings.predictionY)
            PredictedPosition = PredictedPosition + Vector3.new(0, verticalSpeed, 0)
        end
    end
    
    LastTick = currentTick
    LastPosition = currentPos
    return PredictedPosition
end

-- Aimbot FOV visualization
local AimbotFOV = Instance.new("ScreenGui")
AimbotFOV.Parent = game.CoreGui
AimbotFOV.Name = "AimbotFOV"
AimbotFOV.ResetOnSpawn = false

local FOVFilled = Instance.new("Frame")
FOVFilled.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
FOVFilled.BackgroundTransparency = 0.7
FOVFilled.BorderSizePixel = 0
FOVFilled.Parent = AimbotFOV

local UICornerFilled = Instance.new("UICorner")
UICornerFilled.CornerRadius = UDim.new(0.5, 0)
UICornerFilled.Parent = FOVFilled

local FOVOutline = Instance.new("ImageLabel")
FOVOutline.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
FOVOutline.BackgroundTransparency = 1
FOVOutline.Image = "rbxassetid://0"
FOVOutline.BorderSizePixel = 0
FOVOutline.Parent = AimbotFOV

local UIStroke = Instance.new("UIStroke")
UIStroke.Thickness = 2
UIStroke.Color = Color3.fromRGB(255, 0, 0)
UIStroke.Parent = FOVOutline

local UICornerOutline = Instance.new("UICorner")
UICornerOutline.CornerRadius = UDim.new(0.5, 0)
UICornerOutline.Parent = FOVOutline

-- Aimbot logic
local Aiming = false
local TargetPlayer = nil

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode[string.upper(getgenv().AimSettings.AimlockKey)] then
        Aiming = not Aiming
        if Aiming then
            TargetPlayer = FindTarget()
        else
            TargetPlayer = nil
        end
    end
end)

RunService.RenderStepped:Connect(function()
    local fovPosition = UDim2.new(0, Mouse.X - getgenv().AimSettings.FOV/2, 0, Mouse.Y - getgenv().AimSettings.FOV/2)
    FOVFilled.Position = fovPosition
    FOVOutline.Position = fovPosition

    FOVFilled.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
    FOVOutline.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)

    FOVFilled.Visible = getgenv().AimSettings.FOVVisible and getgenv().AimSettings.FOVType == "Filled"
    FOVOutline.Visible = getgenv().AimSettings.FOVVisible and getgenv().AimSettings.FOVType == "Outline"

    if Aiming and getgenv().AimSettings.Enabled then
        if not TargetPlayer or not TargetPlayer.Character or not TargetPlayer.Character:FindFirstChild(getgenv().AimSettings.AimPart) then
            TargetPlayer = FindTarget()
        end

        if TargetPlayer and TargetPlayer.Character then
            local aimPart = TargetPlayer.Character:FindFirstChild(getgenv().AimSettings.AimPart)
            if aimPart then
                if not IsTargetValid(TargetPlayer.Character) or not IsTargetVisible(aimPart) then
                    TargetPlayer = FindTarget()
                    if not TargetPlayer then
                        FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        UIStroke.Color = Color3.fromRGB(255, 0, 0)
                        return
                    end
                end

                local aimPosition = getgenv().AimSettings.PredictMovement and PredictPosition(TargetPlayer) or aimPart.Position
                local newCFrame = CFrame.new(Camera.CFrame.Position, aimPosition)
                Camera.CFrame = Camera.CFrame:Lerp(newCFrame, getgenv().AimSettings.Smoothness)
                
                FOVFilled.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                UIStroke.Color = Color3.fromRGB(0, 255, 0)
                return
            end
        end
    end

    FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    UIStroke.Color = Color3.fromRGB(255, 0, 0)
end)

-- Triggerbot UI Elements
local TriggerbotGroup = Tabs["Combat"]:AddRightGroupbox("Triggerbot Settings")

local TriggerToggle = TriggerbotGroup:AddToggle("TriggerEnabled", {
    Text = "Enable Triggerbot",
    Default = getgenv().TriggerbotSettings.Enabled,
    Tooltip = "Enable/Disable the triggerbot",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Enabled = Value
        if Value and getgenv().TriggerbotSettings.Mode == "Toggle" then
            getgenv().TriggerbotSettings.ToggleState = true
            Library:Notify({
                Title = "Triggerbot",
                Description = "Triggerbot Enabled",
                Time = 3
            })
        elseif not Value then
            getgenv().TriggerbotSettings.ToggleState = false
        end
    end
})

TriggerbotGroup:AddDropdown("TriggerMode", {
    Values = {"Always", "Toggle"},
    Default = getgenv().TriggerbotSettings.Mode,
    Multi = false,
    Text = "Trigger Mode",
    Tooltip = "Select triggerbot activation mode",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Mode = Value
        if Value ~= "Toggle" then
            getgenv().TriggerbotSettings.ToggleState = false
        end
    end
})

local TriggerKeybind = TriggerToggle:AddKeyPicker("TriggerKeybind", {
    Default = getgenv().TriggerbotSettings.Keybind,
    Mode = "Toggle",
    Text = "Trigger Key",
    NoUI = false,
    Callback = function(Value)
        if getgenv().TriggerbotSettings.Mode == "Toggle" and getgenv().TriggerbotSettings.Enabled then
            getgenv().TriggerbotSettings.ToggleState = not getgenv().TriggerbotSettings.ToggleState
            if getgenv().TriggerbotSettings.ToggleState then
                Library:Notify({
                    Title = "Triggerbot",
                    Description = "Triggerbot Enabled",
                    Time = 3
                })
            end
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().TriggerbotSettings.Keybind = NewKey.Name
    end
})

TriggerbotGroup:AddDropdown("TriggerTargetMode", {
    Values = {"Center of Screen", "Mouse Position"},
    Default = getgenv().TriggerbotSettings.TargetMode,
    Multi = false,
    Text = "Target Mode",
    Tooltip = "Select where to aim for triggerbot",
    Callback = function(Value)
        getgenv().TriggerbotSettings.TargetMode = Value
    end
})

TriggerbotGroup:AddSlider("TriggerDelay", {
    Text = "Trigger Delay",
    Default = getgenv().TriggerbotSettings.Delay * 1000,
    Min = 0,
    Max = 1000,
    Rounding = 0,
    Suffix = "ms",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Delay = Value / 1000
    end
})

TriggerbotGroup:AddSlider("TriggerRadius", {
    Text = "Trigger Radius",
    Default = getgenv().TriggerbotSettings.Radius,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        getgenv().TriggerbotSettings.Radius = Value
    end
})

TriggerbotGroup:AddToggle("TriggerCircleVisible", {
    Text = "Show Trigger Circle",
    Default = getgenv().TriggerbotSettings.CircleVisible,
    Tooltip = "Show/Hide the trigger circle",
    Callback = function(Value)
        getgenv().TriggerbotSettings.CircleVisible = Value
    end
})

TriggerbotGroup:AddDropdown("TriggerCircleType", {
    Values = {"Outline", "Filled"},
    Default = getgenv().TriggerbotSettings.CircleType,
    Multi = false,
    Text = "Circle Type",
    Tooltip = "Select trigger circle display type",
    Callback = function(Value)
        getgenv().TriggerbotSettings.CircleType = Value
    end
})

-- Triggerbot Logic
local LastActivationTime = tick()
local GuiInset = GuiService:GetGuiInset()
local TopbarOffset = GuiInset.Y

local CenterTriggerbotFOV = Instance.new("ScreenGui")
CenterTriggerbotFOV.Name = "CenterTriggerbotFOV"
CenterTriggerbotFOV.Parent = game.CoreGui
CenterTriggerbotFOV.IgnoreGuiInset = true

local MouseTriggerbotFOV = Instance.new("ScreenGui")
MouseTriggerbotFOV.Name = "MouseTriggerbotFOV"
MouseTriggerbotFOV.Parent = game.CoreGui
MouseTriggerbotFOV.IgnoreGuiInset = false

local function CreateCircle(name, filled, parent)
    local element = filled and Instance.new("Frame") or Instance.new("ImageLabel")
    element.Name = name
    element.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    element.AnchorPoint = Vector2.new(0.5, 0.5)
    
    if filled then
        element.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        element.BackgroundTransparency = 0.7
    else
        element.BackgroundTransparency = 1
        element.Image = "rbxassetid://0"
        local stroke = Instance.new("UIStroke")
        stroke.Thickness = 2
        stroke.Color = Color3.fromRGB(255, 255, 255)
        stroke.Parent = element
    end
    
    element.BorderSizePixel = 0
    element.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.5, 0)
    corner.Parent = element
    
    return element
end

local CenterFilled = CreateCircle("CenterFilled", true, CenterTriggerbotFOV)
local CenterOutline = CreateCircle("CenterOutline", false, CenterTriggerbotFOV)
local MouseFilled = CreateCircle("MouseFilled", true, MouseTriggerbotFOV)
local MouseOutline = CreateCircle("MouseOutline", false, MouseTriggerbotFOV)

local function WallCheck(part)
    local origin = Camera.CFrame.Position
    local target = part.Position
    local direction = (target - origin).Unit
    local distance = (target - origin).Magnitude
    
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    local result = Workspace:Raycast(origin, direction * distance, params)
    if result then
        local hitPart = result.Instance
        local model = hitPart:FindFirstAncestorOfClass("Model")
        return not (model and Players:GetPlayerFromCharacter(model))
    end
    return true
end

local function UpdateTriggerbot()
    local isActive = getgenv().TriggerbotSettings.Enabled and 
        (getgenv().TriggerbotSettings.Mode == "Always" or 
         (getgenv().TriggerbotSettings.Mode == "Toggle" and getgenv().TriggerbotSettings.ToggleState))
    
    if not isActive then
        CenterFilled.Visible = false
        CenterOutline.Visible = false
        MouseFilled.Visible = false
        MouseOutline.Visible = false
        return
    end

    local targetPos, circlePos, activeFilled, activeOutline
    if getgenv().TriggerbotSettings.TargetMode == "Center of Screen" then
        activeFilled = CenterFilled
        activeOutline = CenterOutline
        MouseFilled.Visible = false
        MouseOutline.Visible = false
        targetPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        circlePos = UDim2.new(0.5, 0, 0.5, 0)
    else
        activeFilled = MouseFilled
        activeOutline = MouseOutline
        CenterFilled.Visible = false
        CenterOutline.Visible = false
        targetPos = Vector2.new(Mouse.X, Mouse.Y)
        circlePos = UDim2.new(0, Mouse.X, 0, Mouse.Y)
    end

    activeFilled.Position = circlePos
    activeOutline.Position = circlePos
    
    activeFilled.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    activeOutline.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    
    activeFilled.Visible = getgenv().TriggerbotSettings.CircleVisible and getgenv().TriggerbotSettings.CircleType == "Filled"
    activeOutline.Visible = getgenv().TriggerbotSettings.CircleVisible and getgenv().TriggerbotSettings.CircleType == "Outline"
    
    local targetFound = false
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local screenPos, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - targetPos).Magnitude
                    if distance <= getgenv().TriggerbotSettings.Radius and not WallCheck(humanoidRootPart) then
                        targetFound = true
                        break
                    end
                end
            end
        end
    end
    
    if targetFound then
        if tick() - LastActivationTime >= getgenv().TriggerbotSettings.Delay then
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") and tool.Parent == character then
                    tool:Activate()
                    task.wait(0.1)
                    tool:Deactivate()
                    LastActivationTime = tick()
                end
            end
        end
        activeFilled.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        if activeOutline:FindFirstChild("UIStroke") then
            activeOutline.UIStroke.Color = Color3.fromRGB(0, 255, 0)
        end
    else
        activeFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        if activeOutline:FindFirstChild("UIStroke") then
            activeOutline.UIStroke.Color = Color3.fromRGB(255, 0, 0)
        end
    end
end

RunService.RenderStepped:Connect(UpdateTriggerbot)

-- Rapid Fire
local RapidFireGroup = Tabs["Combat"]:AddRightGroupbox("Rapid Fire")

local RapidFireToggle = RapidFireGroup:AddToggle("RapidFireToggle", {
    Text = "Enable Rapid Fire",
    Default = false,
    Tooltip = "Hold m1 to shoot",
    Callback = function(Value)
        getgenv().RapidFireEnabled = Value
        Library:Notify("Rapid Fire " .. (Value and "включен" or "выключен"), 2)
    end
})

do
    local firing = false
    local debounce = false
    local minFireDelay = 0.05

    local function SAFEACTIVATE(tool)
        if not debounce and tool and tool:IsA("Tool") and getgenv().RapidFireEnabled then
            debounce = true
            pcall(function()
                tool:Activate()
            end)
            task.wait(minFireDelay)
            debounce = false
        end
    end

    local function fireLoop()
        while firing and getgenv().RapidFireEnabled do
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                SAFEACTIVATE(tool)
            end
            RunService.Heartbeat:Wait()
        end
    end

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 then
            firing = true
            if getgenv().RapidFireEnabled then
                fireLoop()
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            firing = false
        end
    end)

    local function setupCharacter(character)
        character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                child.Activated:Connect(function()
                    if firing and getgenv().RapidFireEnabled then
                        SAFEACTIVATE(child)
                    end
                end)
            end
        end)
    end

    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(character)
        character:WaitForChild("Humanoid")
        setupCharacter(character)
    end)
end

-- Setup ThemeManager and SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("ClickGUI")
SaveManager:SetFolder("ClickGUI/settings")

SaveManager:BuildConfigSection(Tabs["HUD"])
ThemeManager:ApplyToTab(Tabs["HUD"])

-- Show the UI
Library:Toggle(true)
