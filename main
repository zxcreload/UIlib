-- Load the Obsidian UI Library and addons
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

-- Create tabs
local Tabs = {
    Combat = Window:AddTab("Combat", "sword"),
    Movement = Window:AddTab("Movement", "move"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Misc = Window:AddTab("Misc", "box"),
    Other = Window:AddTab("Other", "list"),
    HUD = Window:AddTab("HUD", "monitor"),
}

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")

-- Local variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

-- Aimbot configuration
getgenv().AimSettings = {
    AimPart = "Head",
    FOV = 300,
    FOVVisible = false,
    FOVType = "Outline",
    TeamCheck = false,
    PredictMovement = false,
    Smoothness = 0.15,
    predictionXZ = 0.4,
    predictionY = 0.2,
    WallCheck = false,
    RagdollCheck = false,
    ResolverMode = "Velocity",
    Enabled = false,
    AimlockKey = "E"
}

-- Triggerbot Settings
getgenv().TriggerbotSettings = {
    Enabled = false,
    Delay = 0.1,
    Radius = 100,
    CircleVisible = false,
    CircleType = "Outline",
    Mode = "Always",
    Keybind = "T",
    ToggleState = false,
    TargetMode = "Center of Screen"
}

-- Aimbot UI elements
local AimbotGroup = Tabs["Combat"]:AddLeftGroupbox("Aimbot Settings")
local AimToggle = AimbotGroup:AddToggle("AimEnabled", {
    Text = "Enable Aimbot",
    Default = getgenv().AimSettings.Enabled,
    Tooltip = "Enable/Disable the aimbot",
    Callback = function(Value)
        getgenv().AimSettings.Enabled = Value
    end
})

local AimKeybind = AimToggle:AddKeyPicker("AimKeybind", {
    Default = getgenv().AimSettings.AimlockKey,
    Mode = "Toggle",
    Text = "Aim Key",
    NoUI = false,
    Callback = function(Value) end,
    ChangedCallback = function(NewKey)
        getgenv().AimSettings.AimlockKey = tostring(NewKey):lower()
    end
})

AimbotGroup:AddDropdown("AimPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = getgenv().AimSettings.AimPart,
    Multi = false,
    Text = "Aim Part",
    Tooltip = "Select the part to aim at",
    Callback = function(Value)
        getgenv().AimSettings.AimPart = Value
    end
})

AimbotGroup:AddSlider("FOVSize", {
    Text = "FOV Size",
    Default = getgenv().AimSettings.FOV,
    Min = 50,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        getgenv().AimSettings.FOV = Value
    end
})

AimbotGroup:AddToggle("FOVVisible", {
    Text = "Show FOV",
    Default = getgenv().AimSettings.FOVVisible,
    Tooltip = "Show/Hide the FOV circle",
    Callback = function(Value)
        getgenv().AimSettings.FOVVisible = Value
    end
})

AimbotGroup:AddDropdown("FOVType", {
    Values = {"Outline", "Filled"},
    Default = getgenv().AimSettings.FOVType,
    Multi = false,
    Text = "FOV Type",
    Tooltip = "Select FOV display type",
    Callback = function(Value)
        getgenv().AimSettings.FOVType = Value
    end
})

AimbotGroup:AddToggle("TeamCheck", {
    Text = "Team Check",
    Default = getgenv().AimSettings.TeamCheck,
    Tooltip = "Ignore teammates",
    Callback = function(Value)
        getgenv().AimSettings.TeamCheck = Value
    end
})

AimbotGroup:AddToggle("PredictMovement", {
    Text = "Predict Movement",
    Default = getgenv().AimSettings.PredictMovement,
    Tooltip = "Predict target movement",
    Callback = function(Value)
        getgenv().AimSettings.PredictMovement = Value
    end
})

AimbotGroup:AddSlider("PredictionXZ", {
    Text = "Horizontal Prediction",
    Default = getgenv().AimSettings.predictionXZ * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.predictionXZ = Value / 100
    end
})

AimbotGroup:AddSlider("PredictionY", {
    Text = "Vertical Prediction",
    Default = getgenv().AimSettings.predictionY * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.predictionY = Value / 100
    end
})

AimbotGroup:AddSlider("Smoothness", {
    Text = "Smoothness",
    Default = getgenv().AimSettings.Smoothness * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.Smoothness = Value / 100
    end
})

AimbotGroup:AddDropdown("ResolverMode", {
    Values = {"Velocity", "Move direction", "Calculate CFrame"},
    Default = getgenv().AimSettings.ResolverMode,
    Multi = false,
    Text = "Resolver Mode",
    Tooltip = "Select prediction calculation mode",
    Callback = function(Value)
        getgenv().AimSettings.ResolverMode = Value
    end
})

AimbotGroup:AddToggle("WallCheck", {
    Text = "Wall Check",
    Default = false,
    Tooltip = "Ignore targets behind walls",
    Callback = function(Value)
        getgenv().AimSettings.WallCheck = Value
    end
})

AimbotGroup:AddToggle("RagdollCheck", {
    Text = "Ragdoll Check",
    Default = false,
    Tooltip = "Ignore ragdolled/dead targets",
    Callback = function(Value)
        getgenv().AimSettings.RagdollCheck = Value
    end
})

-- Замените существующую функцию IsTargetVisible на эту
local function IsTargetVisible(targetPart)
    if not getgenv().AimSettings.WallCheck then return true end
    
    local origin = Camera.CFrame.Position
    local targetPos = targetPart.Position
    local direction = (targetPos - origin)
    local distance = direction.Magnitude
    
    -- Настраиваем параметры raycast
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    -- Выполняем raycast
    local result = Workspace:Raycast(origin, direction, params)
    
    if result then
        local hitPart = result.Instance
        -- Проверяем, попали ли мы в часть персонажа цели
        local targetCharacter = targetPart:FindFirstAncestorOfClass("Model")
        local hitCharacter = hitPart:FindFirstAncestorOfClass("Model")
        
        -- Если попали не в персонажа цели, значит есть стена
        if hitCharacter ~= targetCharacter then
            return false
        end
    end
    
    return true
end

-- Также обновим функцию FindTarget для лучшей совместимости
local function FindTarget()
    if not getgenv().AimSettings.Enabled then return nil end
    
    local closestPlayer, closestDistance = nil, math.huge
    local fovRadius = getgenv().AimSettings.FOV / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if getgenv().AimSettings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        
        if not IsTargetValid(character) then continue end
        
        local aimPart = character:FindFirstChild(getgenv().AimSettings.AimPart)
        if not aimPart then continue end
        
        -- Сначала проверяем FOV, затем видимость через стены
        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPart.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance <= fovRadius and distance < closestDistance then
            if IsTargetVisible(aimPart) then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end
    
    return closestPlayer
end

local function IsTargetValid(targetCharacter)
    if not getgenv().AimSettings.RagdollCheck then return true end
    
    local humanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    if humanoid.Health <= 0 then return false end
    
    local states = {
        Enum.HumanoidStateType.FallingDown,
        Enum.HumanoidStateType.Physics,
        Enum.HumanoidStateType.Dead
    }
    
    for _, state in ipairs(states) do
        if humanoid:GetState() == state then
            return false
        end
    end
    
    local rootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if rootPart then
        local characterHeight = targetCharacter:GetExtentsSize().Y
        if rootPart.Position.Y < (characterHeight * 0.5) then
            return false
        end
    end
    
    return true
end

local function FindTarget()
    if not getgenv().AimSettings.Enabled then return nil end
    
    local closestPlayer, closestDistance = nil, math.huge
    local fovRadius = getgenv().AimSettings.FOV / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if getgenv().AimSettings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        
        if not IsTargetValid(character) then continue end
        
        local aimPart = character:FindFirstChild(getgenv().AimSettings.AimPart)
        if not aimPart then continue end
        
        if not IsTargetVisible(aimPart) then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPart.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance <= fovRadius and distance < closestDistance then
            closestDistance = distance
            closestPlayer = player
        end
    end
    
    return closestPlayer
end

local LastPosition, LastTick, PredictedPosition
local function PredictPosition(target)
    if not (target and target.Character) then return nil end
    
    local aimPart = target.Character:FindFirstChild(getgenv().AimSettings.AimPart)
    if not aimPart then return nil end
    
    local currentPos = aimPart.Position
    
    if not (LastPosition and LastTick) then
        LastPosition = currentPos
        LastTick = tick()
        return currentPos
    end
    
    local currentTick = tick()
    local deltaTime = currentTick - LastTick
    
    if getgenv().AimSettings.ResolverMode == "Velocity" then
        local velocity = aimPart.Velocity
        PredictedPosition = currentPos + Vector3.new(
            velocity.X * getgenv().AimSettings.predictionXZ,
            velocity.Y * getgenv().AimSettings.predictionY,
            velocity.Z * getgenv().AimSettings.predictionXZ
        )
    elseif getgenv().AimSettings.ResolverMode == "Move direction" then
        local moveDir = target.Character.Humanoid.MoveDirection
        PredictedPosition = currentPos + (moveDir * (getgenv().AimSettings.predictionXZ * 10))
    else -- "Calculate CFrame"
        if (currentPos - LastPosition).Magnitude < 0.001 then
            PredictedPosition = currentPos
        else
            local distance = (currentPos - LastPosition).Magnitude
            local speed = (distance / deltaTime) * (0.1 * (getgenv().AimSettings.predictionXZ * 10))
            PredictedPosition = currentPos + (currentPos - LastPosition).Unit * speed
            local verticalSpeed = (currentPos.Y - LastPosition.Y) / deltaTime * (0.1 * getgenv().AimSettings.predictionY)
            PredictedPosition = PredictedPosition + Vector3.new(0, verticalSpeed, 0)
        end
    end
    
    LastTick = currentTick
    LastPosition = currentPos
    return PredictedPosition
end

-- Aimbot FOV visualization
local AimbotFOV = Instance.new("ScreenGui")
AimbotFOV.Parent = game.CoreGui
AimbotFOV.Name = "AimbotFOV"
AimbotFOV.ResetOnSpawn = false

local FOVFilled = Instance.new("Frame")
FOVFilled.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
FOVFilled.BackgroundTransparency = 0.7
FOVFilled.BorderSizePixel = 0
FOVFilled.Parent = AimbotFOV

local UICornerFilled = Instance.new("UICorner")
UICornerFilled.CornerRadius = UDim.new(0.5, 0)
UICornerFilled.Parent = FOVFilled

local FOVOutline = Instance.new("ImageLabel")
FOVOutline.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
FOVOutline.BackgroundTransparency = 1
FOVOutline.Image = "rbxassetid://0"
FOVOutline.BorderSizePixel = 0
FOVOutline.Parent = AimbotFOV

local UIStroke = Instance.new("UIStroke")
UIStroke.Thickness = 2
UIStroke.Color = Color3.fromRGB(255, 0, 0)
UIStroke.Parent = FOVOutline

local UICornerOutline = Instance.new("UICorner")
UICornerOutline.CornerRadius = UDim.new(0.5, 0)
UICornerOutline.Parent = FOVOutline

-- Aimbot logic
local Aiming = false
local TargetPlayer = nil

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode[string.upper(getgenv().AimSettings.AimlockKey)] then
        Aiming = not Aiming
        if Aiming then
            TargetPlayer = FindTarget()
        else
            TargetPlayer = nil
        end
    end
end)

RunService.RenderStepped:Connect(function()
    local fovPosition = UDim2.new(0, Mouse.X - getgenv().AimSettings.FOV/2, 0, Mouse.Y - getgenv().AimSettings.FOV/2)
    FOVFilled.Position = fovPosition
    FOVOutline.Position = fovPosition

    FOVFilled.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
    FOVOutline.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)

    FOVFilled.Visible = getgenv().AimSettings.FOVVisible and getgenv().AimSettings.FOVType == "Filled"
    FOVOutline.Visible = getgenv().AimSettings.FOVVisible and getgenv().AimSettings.FOVType == "Outline"

    if Aiming and getgenv().AimSettings.Enabled then
        if not TargetPlayer or not TargetPlayer.Character or not TargetPlayer.Character:FindFirstChild(getgenv().AimSettings.AimPart) then
            TargetPlayer = FindTarget()
        end

        if TargetPlayer and TargetPlayer.Character then
            local aimPart = TargetPlayer.Character:FindFirstChild(getgenv().AimSettings.AimPart)
            if aimPart then
                if not IsTargetValid(TargetPlayer.Character) or not IsTargetVisible(aimPart) then
                    TargetPlayer = FindTarget()
                    if not TargetPlayer then
                        FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        UIStroke.Color = Color3.fromRGB(255, 0, 0)
                        return
                    end
                end

                local aimPosition = getgenv().AimSettings.PredictMovement and PredictPosition(TargetPlayer) or aimPart.Position
                local newCFrame = CFrame.new(Camera.CFrame.Position, aimPosition)
                Camera.CFrame = Camera.CFrame:Lerp(newCFrame, getgenv().AimSettings.Smoothness)
                
                FOVFilled.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                UIStroke.Color = Color3.fromRGB(0, 255, 0)
                return
            end
        end
    end

    FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    UIStroke.Color = Color3.fromRGB(255, 0, 0)
end)

-- Triggerbot UI Elements
local TriggerbotGroup = Tabs["Combat"]:AddRightGroupbox("Triggerbot Settings")

local TriggerToggle = TriggerbotGroup:AddToggle("TriggerEnabled", {
    Text = "Enable Triggerbot",
    Default = getgenv().TriggerbotSettings.Enabled,
    Tooltip = "Enable/Disable the triggerbot",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Enabled = Value
        if Value and getgenv().TriggerbotSettings.Mode == "Toggle" then
            getgenv().TriggerbotSettings.ToggleState = true
            Library:Notify({
                Title = "Triggerbot",
                Description = "Triggerbot Enabled",
                Time = 3
            })
        elseif not Value then
            getgenv().TriggerbotSettings.ToggleState = false
        end
    end
})

TriggerbotGroup:AddDropdown("TriggerMode", {
    Values = {"Always", "Toggle"},
    Default = getgenv().TriggerbotSettings.Mode,
    Multi = false,
    Text = "Trigger Mode",
    Tooltip = "Select triggerbot activation mode",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Mode = Value
        if Value ~= "Toggle" then
            getgenv().TriggerbotSettings.ToggleState = false
        end
    end
})

local TriggerKeybind = TriggerToggle:AddKeyPicker("TriggerKeybind", {
    Default = getgenv().TriggerbotSettings.Keybind,
    Mode = "Toggle",
    Text = "Trigger Key",
    NoUI = false,
    Callback = function(Value)
        if getgenv().TriggerbotSettings.Mode == "Toggle" and getgenv().TriggerbotSettings.Enabled then
            getgenv().TriggerbotSettings.ToggleState = not getgenv().TriggerbotSettings.ToggleState
            if getgenv().TriggerbotSettings.ToggleState then
                Library:Notify({
                    Title = "Triggerbot",
                    Description = "Triggerbot Enabled",
                    Time = 3
                })
            end
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().TriggerbotSettings.Keybind = NewKey.Name
    end
})

TriggerbotGroup:AddDropdown("TriggerTargetMode", {
    Values = {"Center of Screen", "Mouse Position"},
    Default = getgenv().TriggerbotSettings.TargetMode,
    Multi = false,
    Text = "Target Mode",
    Tooltip = "Select where to aim for triggerbot",
    Callback = function(Value)
        getgenv().TriggerbotSettings.TargetMode = Value
    end
})

TriggerbotGroup:AddSlider("TriggerDelay", {
    Text = "Trigger Delay",
    Default = getgenv().TriggerbotSettings.Delay * 1000,
    Min = 0,
    Max = 1000,
    Rounding = 0,
    Suffix = "ms",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Delay = Value / 1000
    end
})

TriggerbotGroup:AddSlider("TriggerRadius", {
    Text = "Trigger Radius",
    Default = getgenv().TriggerbotSettings.Radius,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        getgenv().TriggerbotSettings.Radius = Value
    end
})

TriggerbotGroup:AddToggle("TriggerCircleVisible", {
    Text = "Show Trigger Circle",
    Default = getgenv().TriggerbotSettings.CircleVisible,
    Tooltip = "Show/Hide the trigger circle",
    Callback = function(Value)
        getgenv().TriggerbotSettings.CircleVisible = Value
    end
})

TriggerbotGroup:AddDropdown("TriggerCircleType", {
    Values = {"Outline", "Filled"},
    Default = getgenv().TriggerbotSettings.CircleType,
    Multi = false,
    Text = "Circle Type",
    Tooltip = "Select trigger circle display type",
    Callback = function(Value)
        getgenv().TriggerbotSettings.CircleType = Value
    end
})

-- Triggerbot Logic
local LastActivationTime = tick()
local GuiInset = GuiService:GetGuiInset()
local TopbarOffset = GuiInset.Y

local CenterTriggerbotFOV = Instance.new("ScreenGui")
CenterTriggerbotFOV.Name = "CenterTriggerbotFOV"
CenterTriggerbotFOV.Parent = game.CoreGui
CenterTriggerbotFOV.IgnoreGuiInset = true

local MouseTriggerbotFOV = Instance.new("ScreenGui")
MouseTriggerbotFOV.Name = "MouseTriggerbotFOV"
MouseTriggerbotFOV.Parent = game.CoreGui
MouseTriggerbotFOV.IgnoreGuiInset = false

local function CreateCircle(name, filled, parent)
    local element = filled and Instance.new("Frame") or Instance.new("ImageLabel")
    element.Name = name
    element.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    element.AnchorPoint = Vector2.new(0.5, 0.5)
    
    if filled then
        element.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        element.BackgroundTransparency = 0.7
    else
        element.BackgroundTransparency = 1
        element.Image = "rbxassetid://0"
        local stroke = Instance.new("UIStroke")
        stroke.Thickness = 2
        stroke.Color = Color3.fromRGB(255, 255, 255)
        stroke.Parent = element
    end
    
    element.BorderSizePixel = 0
    element.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.5, 0)
    corner.Parent = element
    
    return element
end

local CenterFilled = CreateCircle("CenterFilled", true, CenterTriggerbotFOV)
local CenterOutline = CreateCircle("CenterOutline", false, CenterTriggerbotFOV)
local MouseFilled = CreateCircle("MouseFilled", true, MouseTriggerbotFOV)
local MouseOutline = CreateCircle("MouseOutline", false, MouseTriggerbotFOV)

local function WallCheck(part)
    local origin = Camera.CFrame.Position
    local target = part.Position
    local direction = (target - origin).Unit
    local distance = (target - origin).Magnitude
    
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    local result = Workspace:Raycast(origin, direction * distance, params)
    if result then
        local hitPart = result.Instance
        local model = hitPart:FindFirstAncestorOfClass("Model")
        return not (model and Players:GetPlayerFromCharacter(model))
    end
    return true
end

local function UpdateTriggerbot()
    local isActive = getgenv().TriggerbotSettings.Enabled and 
        (getgenv().TriggerbotSettings.Mode == "Always" or 
         (getgenv().TriggerbotSettings.Mode == "Toggle" and getgenv().TriggerbotSettings.ToggleState))
    
    if not isActive then
        CenterFilled.Visible = false
        CenterOutline.Visible = false
        MouseFilled.Visible = false
        MouseOutline.Visible = false
        return
    end

    local targetPos, circlePos, activeFilled, activeOutline
    if getgenv().TriggerbotSettings.TargetMode == "Center of Screen" then
        activeFilled = CenterFilled
        activeOutline = CenterOutline
        MouseFilled.Visible = false
        MouseOutline.Visible = false
        targetPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        circlePos = UDim2.new(0.5, 0, 0.5, 0)
    else
        activeFilled = MouseFilled
        activeOutline = MouseOutline
        CenterFilled.Visible = false
        CenterOutline.Visible = false
        targetPos = Vector2.new(Mouse.X, Mouse.Y)
        circlePos = UDim2.new(0, Mouse.X, 0, Mouse.Y)
    end

    activeFilled.Position = circlePos
    activeOutline.Position = circlePos
    
    activeFilled.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    activeOutline.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    
    activeFilled.Visible = getgenv().TriggerbotSettings.CircleVisible and getgenv().TriggerbotSettings.CircleType == "Filled"
    activeOutline.Visible = getgenv().TriggerbotSettings.CircleVisible and getgenv().TriggerbotSettings.CircleType == "Outline"
    
    local targetFound = false
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local screenPos, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - targetPos).Magnitude
                    if distance <= getgenv().TriggerbotSettings.Radius and not WallCheck(humanoidRootPart) then
                        targetFound = true
                        break
                    end
                end
            end
        end
    end
    
    if targetFound then
        if tick() - LastActivationTime >= getgenv().TriggerbotSettings.Delay then
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") and tool.Parent == character then
                    tool:Activate()
                    task.wait(0.1)
                    tool:Deactivate()
                    LastActivationTime = tick()
                end
            end
        end
        activeFilled.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        if activeOutline:FindFirstChild("UIStroke") then
            activeOutline.UIStroke.Color = Color3.fromRGB(0, 255, 0)
        end
    else
        activeFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        if activeOutline:FindFirstChild("UIStroke") then
            activeOutline.UIStroke.Color = Color3.fromRGB(255, 0, 0)
        end
    end
end

RunService.RenderStepped:Connect(UpdateTriggerbot)

-- Rapid Fire
local RapidFireGroup = Tabs["Combat"]:AddRightGroupbox("Rapid Fire")

local RapidFireToggle = RapidFireGroup:AddToggle("RapidFireToggle", {
    Text = "Enable Rapid Fire",
    Default = false,
    Tooltip = "Hold m1 to shoot",
    Callback = function(Value)
        getgenv().RapidFireEnabled = Value
        Library:Notify("Rapid Fire " .. (Value and "включен" or "выключен"), 2)
    end
})

do
    local firing = false
    local debounce = false
    local minFireDelay = 0.05

    local function SAFEACTIVATE(tool)
        if not debounce and tool and tool:IsA("Tool") and getgenv().RapidFireEnabled then
            debounce = true
            pcall(function()
                tool:Activate()
            end)
            task.wait(minFireDelay)
            debounce = false
        end
    end

    local function fireLoop()
        while firing and getgenv().RapidFireEnabled do
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                SAFEACTIVATE(tool)
            end
            RunService.Heartbeat:Wait()
        end
    end

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 then
            firing = true
            if getgenv().RapidFireEnabled then
                fireLoop()
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            firing = false
        end
    end)

    local function setupCharacter(character)
        character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                child.Activated:Connect(function()
                    if firing and getgenv().RapidFireEnabled then
                        SAFEACTIVATE(child)
                    end
                end)
            end
        end)
    end

    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(character)
        character:WaitForChild("Humanoid")
        setupCharacter(character)
    end)
end

-- Pro Aim Settings
local ProAimGroup = Tabs["Combat"]:AddLeftGroupbox("Pro Aim Settings")

-- Глобальные переменные для Pro Aim
getgenv().ProAimSettings = {
    Enabled = false,
    Keybind = "F",
    ShowFOV = false,
    FOVSize = 300,
    Mode = "InFov", -- "InFov" или "Target"
    TargetPlayer = nil, -- Ник выбранного игрока для режима Target
    Distance = 10 -- Дальность закрепления
}

local isActive = false
local connection
local fovConnection
local targetPlayer = nil
local targetRootPart = nil
local targetESP = nil
local originalCFrame = nil
local wasAnchored = false
local wasCanCollide = false

-- Создание FOV круга
local fovCircle = Drawing and Drawing.new("Circle")
if fovCircle then
    fovCircle.Radius = getgenv().ProAimSettings.FOVSize
    fovCircle.Thickness = 2
    fovCircle.Color = Color3.fromRGB(255, 255, 255)
    fovCircle.Filled = false
    fovCircle.Visible = getgenv().ProAimSettings.ShowFOV
end

-- Функция создания ESP
local function createESP(part, color, name)
    if not part or not part.Parent then return nil end
    local esp = Instance.new("BoxHandleAdornment")
    esp.Name = name
    esp.Adornee = part
    esp.AlwaysOnTop = true
    esp.ZIndex = 10
    esp.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
    esp.Transparency = 0.5
    esp.Color3 = color
    esp.Parent = part
    return esp
end

-- Функция удаления ESP
local function clearESP()
    if targetESP then
        targetESP:Destroy()
        targetESP = nil
    end
end

-- Поиск корневой части
local function findRootPart(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart") or
                     character:FindFirstChild("Torso") or
                     character:FindFirstChild("UpperTorso") or
                     character:FindFirstChild("LowerTorso")
    if not rootPart then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") and string.find(part.Name:lower(), "torso") then
                rootPart = part
                break
            end
        end
    end
    return rootPart
end

-- Поиск ближайшего игрока к курсору
local function findClosestPlayerToCursor()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePosition = UserInputService:GetMouseLocation()
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local rootPart = findRootPart(player.Character)
            if rootPart then
                local screenPoint = Camera:WorldToViewportPoint(rootPart.Position)
                local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePosition).Magnitude
                if getgenv().ProAimSettings.Mode == "InFov" and distance <= getgenv().ProAimSettings.FOVSize or
                   getgenv().ProAimSettings.Mode == "Target" and player.Name == getgenv().ProAimSettings.TargetPlayer then
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Обновление позиции цели
local function updateTargetPosition()
    if not targetPlayer or not targetPlayer.Parent or not targetPlayer.Character or not targetPlayer.Character.Parent then
        targetPlayer = nil
        clearESP()
        return
    end
    
    if not LocalPlayer.Character or not findRootPart(LocalPlayer.Character) then return end
    
    targetRootPart = findRootPart(targetPlayer.Character)
    if not targetRootPart then
        targetPlayer = nil
        clearESP()
        return
    end
    
    if not originalCFrame then
        originalCFrame = targetRootPart.CFrame
    end
    
    if targetRootPart.Anchored then
        wasAnchored = true
        targetRootPart.Anchored = false
    else
        wasAnchored = false
    end
    
    if targetRootPart.CanCollide then
        wasCanCollide = true
        targetRootPart.CanCollide = false
    else
        wasCanCollide = false
    end
    
    local localPlayerRootPart = findRootPart(LocalPlayer.Character)
    local offsetPosition = localPlayerRootPart.Position + (localPlayerRootPart.CFrame.LookVector * getgenv().ProAimSettings.Distance)
    targetRootPart.CFrame = CFrame.new(offsetPosition)
    
    clearESP()
    targetESP = createESP(targetRootPart, Color3.new(1, 0, 0), "TargetESP")
end

-- Запуск Pro Aim
local function startProAim()
    if not isActive then
        isActive = true
        connection = RunService.Heartbeat:Connect(function()
            local closestPlayer = findClosestPlayerToCursor()
            
            if closestPlayer ~= targetPlayer then
                if targetPlayer and targetRootPart and originalCFrame then
                    targetRootPart.CFrame = originalCFrame
                    if wasAnchored then targetRootPart.Anchored = true end
                    if wasCanCollide then targetRootPart.CanCollide = true end
                    originalCFrame = nil
                end
                targetPlayer = closestPlayer
                clearESP()
            end
            
            if targetPlayer and targetPlayer.Character and targetPlayer.Character.Parent then
                updateTargetPosition()
            else
                if targetPlayer and targetRootPart and originalCFrame then
                    targetRootPart.CFrame = originalCFrame
                    if wasAnchored then targetRootPart.Anchored = true end
                    if wasCanCollide then targetRootPart.CanCollide = true end
                    originalCFrame = nil
                end
                targetPlayer = nil
                clearESP()
            end
        end)
    end
end

-- Остановка Pro Aim
local function stopProAim()
    if isActive then
        isActive = false
        if targetPlayer and targetRootPart and originalCFrame then
            targetRootPart.CFrame = originalCFrame
            if wasAnchored then targetRootPart.Anchored = true end
            if wasCanCollide then targetRootPart.CanCollide = true end
            originalCFrame = nil
        end
        targetPlayer = nil
        targetRootPart = nil
        clearESP()
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
end

-- Обновление FOV
if Drawing then
    fovConnection = RunService.Heartbeat:Connect(function()
        local mousePosition = UserInputService:GetMouseLocation()
        fovCircle.Position = mousePosition
        fovCircle.Radius = getgenv().ProAimSettings.FOVSize
        fovCircle.Visible = getgenv().ProAimSettings.ShowFOV and getgenv().ProAimSettings.Enabled
    end)
end

-- UI элементы для Pro Aim
local ProAimToggle = ProAimGroup:AddToggle("ProAimEnabled", {
    Text = "Enable Pro Aim",
    Default = getgenv().ProAimSettings.Enabled,
    Tooltip = "Enable/Disable Pro Aim",
    Callback = function(Value)
        getgenv().ProAimSettings.Enabled = Value
        if Value then
            startProAim()
        else
            stopProAim()
        end
    end
})

local ProAimKeybind = ProAimToggle:AddKeyPicker("ProAimKeybind", {
    Default = getgenv().ProAimSettings.Keybind,
    Mode = "Toggle",
    Text = "Pro Aim Key",
    NoUI = false,
    Callback = function(Value)
        if getgenv().ProAimSettings.Enabled then
            if isActive then
                stopProAim()
            else
                startProAim()
            end
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().ProAimSettings.Keybind = tostring(NewKey):lower()
    end
})

ProAimGroup:AddToggle("ProAimShowFOV", {
    Text = "Show FOV",
    Default = getgenv().ProAimSettings.ShowFOV,
    Tooltip = "Show/Hide the FOV circle",
    Callback = function(Value)
        getgenv().ProAimSettings.ShowFOV = Value
        if fovCircle then fovCircle.Visible = Value and getgenv().ProAimSettings.Enabled end
    end
})

ProAimGroup:AddSlider("ProAimFOVSize", {
    Text = "FOV Size",
    Default = getgenv().ProAimSettings.FOVSize,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        getgenv().ProAimSettings.FOVSize = Value
        if fovCircle then fovCircle.Radius = Value end
    end
})

ProAimGroup:AddSlider("ProAimDistance", {
    Text = "Target Distance",
    Default = getgenv().ProAimSettings.Distance,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Suffix = " studs",
    Callback = function(Value)
        getgenv().ProAimSettings.Distance = Value
    end
})

local ProAimModeDropdown = ProAimGroup:AddDropdown("ProAimMode", {
    Values = {"InFov", "Target"},
    Default = getgenv().ProAimSettings.Mode,
    Multi = false,
    Text = "Pro Aim Mode",
    Tooltip = "Select Pro Aim mode",
    Callback = function(Value)
        getgenv().ProAimSettings.Mode = Value
    end
})

-- Динамическое обновление списка игроков
local function updatePlayerList()
    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

local TargetPlayerDropdown = ProAimGroup:AddDropdown("ProAimTargetPlayer", {
    Values = updatePlayerList(),
    Default = getgenv().ProAimSettings.TargetPlayer,
    Multi = false,
    Text = "Target Player",
    Tooltip = "Select target player for Target mode",
    Callback = function(Value)
        getgenv().ProAimSettings.TargetPlayer = Value
    end
})

-- Обновление списка игроков при изменении состава
Players.PlayerAdded:Connect(function()
    TargetPlayerDropdown:SetValues(updatePlayerList())
end)

Players.PlayerRemoving:Connect(function(player)
    TargetPlayerDropdown:SetValues(updatePlayerList())
    if getgenv().ProAimSettings.TargetPlayer == player.Name then
        getgenv().ProAimSettings.TargetPlayer = nil
        TargetPlayerDropdown:SetValue(nil)
        stopProAim()
    end
end)

-- Проверка смерти цели
RunService.Heartbeat:Connect(function()
    if getgenv().ProAimSettings.Mode == "Target" and getgenv().ProAimSettings.TargetPlayer then
        local target = Players:FindFirstChild(getgenv().ProAimSettings.TargetPlayer)
        if target and target.Character then
            local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                stopProAim()
            end
        else
            stopProAim()
        end
    end
end)

-- Очистка при выходе игрока
LocalPlayer.AncestryChanged:Connect(function()
    if fovConnection then
        fovConnection:Disconnect()
        fovConnection = nil
    end
    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end
    stopProAim()
end)


-- Setup ThemeManager and SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("ClickGUI")
SaveManager:SetFolder("ClickGUI/settings")

SaveManager:BuildConfigSection(Tabs["HUD"])
ThemeManager:ApplyToTab(Tabs["HUD"])

-- Show the UI
Library:Toggle(true)
