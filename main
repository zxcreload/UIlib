-- Load the Obsidian UI Library and addons
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Create the main window
local Window = Library:CreateWindow({
    Title = "TitanCX",
    Footer = "Cursed by 32vision",
    ShowCustomCursor = false,
})

-- Create tabs
local Tabs = {
    Combat = Window:AddTab("Combat", "sword"),
    Movement = Window:AddTab("Movement", "move"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Misc = Window:AddTab("Misc", "box"),
    Other = Window:AddTab("Other", "list"),
    HUD = Window:AddTab("HUD", "monitor"),
}

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")

-- Local variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

-- Aimbot configuration
getgenv().AimSettings = {
    AimPart = "Head",
    FOV = 300,
    FOVVisible = false,
    FOVType = "Outline",
    TeamCheck = false,
    PredictMovement = false,
    Smoothness = 0.15,
    predictionXZ = 0.4,
    predictionY = 0.2,
    WallCheck = false,
    RagdollCheck = false,
    ResolverMode = "Velocity",
    Enabled = false,
    AimlockKey = "E"
}

-- Triggerbot Settings
getgenv().TriggerbotSettings = {
    Enabled = false,
    Delay = 0.1,
    Radius = 100,
    CircleVisible = false,
    CircleType = "Outline",
    Mode = "Always",
    Keybind = "T",
    ToggleState = false,
    TargetMode = "Center of Screen"
}

-- Aimbot UI elements
local AimbotGroup = Tabs["Combat"]:AddLeftGroupbox("Aimbot Settings")
local AimToggle = AimbotGroup:AddToggle("AimEnabled", {
    Text = "Enable Aimbot",
    Default = getgenv().AimSettings.Enabled,
    Tooltip = "Enable/Disable the aimbot",
    Callback = function(Value)
        getgenv().AimSettings.Enabled = Value
    end
})

local AimKeybind = AimToggle:AddKeyPicker("AimKeybind", {
    Default = getgenv().AimSettings.AimlockKey,
    Mode = "Toggle",
    Text = "Aim Key",
    NoUI = false,
    Callback = function(Value) end,
    ChangedCallback = function(NewKey)
        getgenv().AimSettings.AimlockKey = tostring(NewKey):lower()
    end
})

AimbotGroup:AddDropdown("AimPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = getgenv().AimSettings.AimPart,
    Multi = false,
    Text = "Aim Part",
    Tooltip = "Select the part to aim at",
    Callback = function(Value)
        getgenv().AimSettings.AimPart = Value
    end
})

AimbotGroup:AddSlider("FOVSize", {
    Text = "FOV Size",
    Default = getgenv().AimSettings.FOV,
    Min = 50,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        getgenv().AimSettings.FOV = Value
    end
})

AimbotGroup:AddToggle("FOVVisible", {
    Text = "Show FOV",
    Default = getgenv().AimSettings.FOVVisible,
    Tooltip = "Show/Hide the FOV circle",
    Callback = function(Value)
        getgenv().AimSettings.FOVVisible = Value
    end
})

AimbotGroup:AddDropdown("FOVType", {
    Values = {"Outline", "Filled"},
    Default = getgenv().AimSettings.FOVType,
    Multi = false,
    Text = "FOV Type",
    Tooltip = "Select FOV display type",
    Callback = function(Value)
        getgenv().AimSettings.FOVType = Value
    end
})

AimbotGroup:AddToggle("TeamCheck", {
    Text = "Team Check",
    Default = getgenv().AimSettings.TeamCheck,
    Tooltip = "Ignore teammates",
    Callback = function(Value)
        getgenv().AimSettings.TeamCheck = Value
    end
})

AimbotGroup:AddToggle("PredictMovement", {
    Text = "Predict Movement",
    Default = getgenv().AimSettings.PredictMovement,
    Tooltip = "Predict target movement",
    Callback = function(Value)
        getgenv().AimSettings.PredictMovement = Value
    end
})

AimbotGroup:AddSlider("PredictionXZ", {
    Text = "Horizontal Prediction",
    Default = getgenv().AimSettings.predictionXZ * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.predictionXZ = Value / 100
    end
})

AimbotGroup:AddSlider("PredictionY", {
    Text = "Vertical Prediction",
    Default = getgenv().AimSettings.predictionY * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.predictionY = Value / 100
    end
})

AimbotGroup:AddSlider("Smoothness", {
    Text = "Smoothness",
    Default = getgenv().AimSettings.Smoothness * 100,
    Min = 0,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Suffix = "%",
    Callback = function(Value)
        getgenv().AimSettings.Smoothness = Value / 100
    end
})

AimbotGroup:AddDropdown("ResolverMode", {
    Values = {"Velocity", "Move direction", "Calculate CFrame"},
    Default = getgenv().AimSettings.ResolverMode,
    Multi = false,
    Text = "Resolver Mode",
    Tooltip = "Select prediction calculation mode",
    Callback = function(Value)
        getgenv().AimSettings.ResolverMode = Value
    end
})

AimbotGroup:AddToggle("WallCheck", {
    Text = "Wall Check",
    Default = false,
    Tooltip = "Ignore targets behind walls",
    Callback = function(Value)
        getgenv().AimSettings.WallCheck = Value
    end
})

AimbotGroup:AddToggle("RagdollCheck", {
    Text = "Ragdoll Check",
    Default = false,
    Tooltip = "Ignore ragdolled/dead targets",
    Callback = function(Value)
        getgenv().AimSettings.RagdollCheck = Value
    end
})

-- Замените существующую функцию IsTargetVisible на эту
local function IsTargetVisible(targetPart)
    if not getgenv().AimSettings.WallCheck then return true end
    
    local origin = Camera.CFrame.Position
    local targetPos = targetPart.Position
    local direction = (targetPos - origin)
    local distance = direction.Magnitude
    
    -- Настраиваем параметры raycast
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    -- Выполняем raycast
    local result = Workspace:Raycast(origin, direction, params)
    
    if result then
        local hitPart = result.Instance
        -- Проверяем, попали ли мы в часть персонажа цели
        local targetCharacter = targetPart:FindFirstAncestorOfClass("Model")
        local hitCharacter = hitPart:FindFirstAncestorOfClass("Model")
        
        -- Если попали не в персонажа цели, значит есть стена
        if hitCharacter ~= targetCharacter then
            return false
        end
    end
    
    return true
end

-- Также обновим функцию FindTarget для лучшей совместимости
local function FindTarget()
    if not getgenv().AimSettings.Enabled then return nil end
    
    local closestPlayer, closestDistance = nil, math.huge
    local fovRadius = getgenv().AimSettings.FOV / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if getgenv().AimSettings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        
        if not IsTargetValid(character) then continue end
        
        local aimPart = character:FindFirstChild(getgenv().AimSettings.AimPart)
        if not aimPart then continue end
        
        -- Сначала проверяем FOV, затем видимость через стены
        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPart.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance <= fovRadius and distance < closestDistance then
            if IsTargetVisible(aimPart) then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end
    
    return closestPlayer
end

local function IsTargetValid(targetCharacter)
    if not getgenv().AimSettings.RagdollCheck then return true end
    
    local humanoid = targetCharacter:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    if humanoid.Health <= 0 then return false end
    
    local states = {
        Enum.HumanoidStateType.FallingDown,
        Enum.HumanoidStateType.Physics,
        Enum.HumanoidStateType.Dead
    }
    
    for _, state in ipairs(states) do
        if humanoid:GetState() == state then
            return false
        end
    end
    
    local rootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if rootPart then
        local characterHeight = targetCharacter:GetExtentsSize().Y
        if rootPart.Position.Y < (characterHeight * 0.5) then
            return false
        end
    end
    
    return true
end

local function FindTarget()
    if not getgenv().AimSettings.Enabled then return nil end
    
    local closestPlayer, closestDistance = nil, math.huge
    local fovRadius = getgenv().AimSettings.FOV / 2
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if getgenv().AimSettings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then continue end
        
        if not IsTargetValid(character) then continue end
        
        local aimPart = character:FindFirstChild(getgenv().AimSettings.AimPart)
        if not aimPart then continue end
        
        if not IsTargetVisible(aimPart) then continue end
        
        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPart.Position)
        if not onScreen then continue end
        
        local distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
        if distance <= fovRadius and distance < closestDistance then
            closestDistance = distance
            closestPlayer = player
        end
    end
    
    return closestPlayer
end

local LastPosition, LastTick, PredictedPosition
local function PredictPosition(target)
    if not (target and target.Character) then return nil end
    
    local aimPart = target.Character:FindFirstChild(getgenv().AimSettings.AimPart)
    if not aimPart then return nil end
    
    local currentPos = aimPart.Position
    
    if not (LastPosition and LastTick) then
        LastPosition = currentPos
        LastTick = tick()
        return currentPos
    end
    
    local currentTick = tick()
    local deltaTime = currentTick - LastTick
    
    if getgenv().AimSettings.ResolverMode == "Velocity" then
        local velocity = aimPart.Velocity
        PredictedPosition = currentPos + Vector3.new(
            velocity.X * getgenv().AimSettings.predictionXZ,
            velocity.Y * getgenv().AimSettings.predictionY,
            velocity.Z * getgenv().AimSettings.predictionXZ
        )
    elseif getgenv().AimSettings.ResolverMode == "Move direction" then
        local moveDir = target.Character.Humanoid.MoveDirection
        PredictedPosition = currentPos + (moveDir * (getgenv().AimSettings.predictionXZ * 10))
    else -- "Calculate CFrame"
        if (currentPos - LastPosition).Magnitude < 0.001 then
            PredictedPosition = currentPos
        else
            local distance = (currentPos - LastPosition).Magnitude
            local speed = (distance / deltaTime) * (0.1 * (getgenv().AimSettings.predictionXZ * 10))
            PredictedPosition = currentPos + (currentPos - LastPosition).Unit * speed
            local verticalSpeed = (currentPos.Y - LastPosition.Y) / deltaTime * (0.1 * getgenv().AimSettings.predictionY)
            PredictedPosition = PredictedPosition + Vector3.new(0, verticalSpeed, 0)
        end
    end
    
    LastTick = currentTick
    LastPosition = currentPos
    return PredictedPosition
end

-- Aimbot FOV visualization
local AimbotFOV = Instance.new("ScreenGui")
AimbotFOV.Parent = game.CoreGui
AimbotFOV.Name = "AimbotFOV"
AimbotFOV.ResetOnSpawn = false

local FOVFilled = Instance.new("Frame")
FOVFilled.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
FOVFilled.BackgroundTransparency = 0.7
FOVFilled.BorderSizePixel = 0
FOVFilled.Parent = AimbotFOV

local UICornerFilled = Instance.new("UICorner")
UICornerFilled.CornerRadius = UDim.new(0.5, 0)
UICornerFilled.Parent = FOVFilled

local FOVOutline = Instance.new("ImageLabel")
FOVOutline.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
FOVOutline.BackgroundTransparency = 1
FOVOutline.Image = "rbxassetid://0"
FOVOutline.BorderSizePixel = 0
FOVOutline.Parent = AimbotFOV

local UIStroke = Instance.new("UIStroke")
UIStroke.Thickness = 2
UIStroke.Color = Color3.fromRGB(255, 0, 0)
UIStroke.Parent = FOVOutline

local UICornerOutline = Instance.new("UICorner")
UICornerOutline.CornerRadius = UDim.new(0.5, 0)
UICornerOutline.Parent = FOVOutline

-- Aimbot logic
local Aiming = false
local TargetPlayer = nil

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode[string.upper(getgenv().AimSettings.AimlockKey)] then
        Aiming = not Aiming
        if Aiming then
            TargetPlayer = FindTarget()
        else
            TargetPlayer = nil
        end
    end
end)

RunService.RenderStepped:Connect(function()
    local fovPosition = UDim2.new(0, Mouse.X - getgenv().AimSettings.FOV/2, 0, Mouse.Y - getgenv().AimSettings.FOV/2)
    FOVFilled.Position = fovPosition
    FOVOutline.Position = fovPosition

    FOVFilled.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)
    FOVOutline.Size = UDim2.new(0, getgenv().AimSettings.FOV, 0, getgenv().AimSettings.FOV)

    FOVFilled.Visible = getgenv().AimSettings.FOVVisible and getgenv().AimSettings.FOVType == "Filled"
    FOVOutline.Visible = getgenv().AimSettings.FOVVisible and getgenv().AimSettings.FOVType == "Outline"

    if Aiming and getgenv().AimSettings.Enabled then
        if not TargetPlayer or not TargetPlayer.Character or not TargetPlayer.Character:FindFirstChild(getgenv().AimSettings.AimPart) then
            TargetPlayer = FindTarget()
        end

        if TargetPlayer and TargetPlayer.Character then
            local aimPart = TargetPlayer.Character:FindFirstChild(getgenv().AimSettings.AimPart)
            if aimPart then
                if not IsTargetValid(TargetPlayer.Character) or not IsTargetVisible(aimPart) then
                    TargetPlayer = FindTarget()
                    if not TargetPlayer then
                        FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        UIStroke.Color = Color3.fromRGB(255, 0, 0)
                        return
                    end
                end

                local aimPosition = getgenv().AimSettings.PredictMovement and PredictPosition(TargetPlayer) or aimPart.Position
                local newCFrame = CFrame.new(Camera.CFrame.Position, aimPosition)
                Camera.CFrame = Camera.CFrame:Lerp(newCFrame, getgenv().AimSettings.Smoothness)
                
                FOVFilled.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                UIStroke.Color = Color3.fromRGB(0, 255, 0)
                return
            end
        end
    end

    FOVFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    UIStroke.Color = Color3.fromRGB(255, 0, 0)
end)

-- Triggerbot UI Elements
local TriggerbotGroup = Tabs["Combat"]:AddRightGroupbox("Triggerbot Settings")

local TriggerToggle = TriggerbotGroup:AddToggle("TriggerEnabled", {
    Text = "Enable Triggerbot",
    Default = getgenv().TriggerbotSettings.Enabled,
    Tooltip = "Enable/Disable the triggerbot",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Enabled = Value
        if Value and getgenv().TriggerbotSettings.Mode == "Toggle" then
            getgenv().TriggerbotSettings.ToggleState = true
            Library:Notify({
                Title = "Triggerbot",
                Description = "Triggerbot Enabled",
                Time = 3
            })
        elseif not Value then
            getgenv().TriggerbotSettings.ToggleState = false
        end
    end
})

TriggerbotGroup:AddDropdown("TriggerMode", {
    Values = {"Always", "Toggle"},
    Default = getgenv().TriggerbotSettings.Mode,
    Multi = false,
    Text = "Trigger Mode",
    Tooltip = "Select triggerbot activation mode",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Mode = Value
        if Value ~= "Toggle" then
            getgenv().TriggerbotSettings.ToggleState = false
        end
    end
})

local TriggerKeybind = TriggerToggle:AddKeyPicker("TriggerKeybind", {
    Default = getgenv().TriggerbotSettings.Keybind,
    Mode = "Toggle",
    Text = "Trigger Key",
    NoUI = false,
    Callback = function(Value)
        if getgenv().TriggerbotSettings.Mode == "Toggle" and getgenv().TriggerbotSettings.Enabled then
            getgenv().TriggerbotSettings.ToggleState = not getgenv().TriggerbotSettings.ToggleState
            if getgenv().TriggerbotSettings.ToggleState then
                Library:Notify({
                    Title = "Triggerbot",
                    Description = "Triggerbot Enabled",
                    Time = 3
                })
            end
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().TriggerbotSettings.Keybind = NewKey.Name
    end
})

TriggerbotGroup:AddDropdown("TriggerTargetMode", {
    Values = {"Center of Screen", "Mouse Position"},
    Default = getgenv().TriggerbotSettings.TargetMode,
    Multi = false,
    Text = "Target Mode",
    Tooltip = "Select where to aim for triggerbot",
    Callback = function(Value)
        getgenv().TriggerbotSettings.TargetMode = Value
    end
})

TriggerbotGroup:AddSlider("TriggerDelay", {
    Text = "Trigger Delay",
    Default = getgenv().TriggerbotSettings.Delay * 1000,
    Min = 0,
    Max = 1000,
    Rounding = 0,
    Suffix = "ms",
    Callback = function(Value)
        getgenv().TriggerbotSettings.Delay = Value / 1000
    end
})

TriggerbotGroup:AddSlider("TriggerRadius", {
    Text = "Trigger Radius",
    Default = getgenv().TriggerbotSettings.Radius,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        getgenv().TriggerbotSettings.Radius = Value
    end
})

TriggerbotGroup:AddToggle("TriggerCircleVisible", {
    Text = "Show Trigger Circle",
    Default = getgenv().TriggerbotSettings.CircleVisible,
    Tooltip = "Show/Hide the trigger circle",
    Callback = function(Value)
        getgenv().TriggerbotSettings.CircleVisible = Value
    end
})

TriggerbotGroup:AddDropdown("TriggerCircleType", {
    Values = {"Outline", "Filled"},
    Default = getgenv().TriggerbotSettings.CircleType,
    Multi = false,
    Text = "Circle Type",
    Tooltip = "Select trigger circle display type",
    Callback = function(Value)
        getgenv().TriggerbotSettings.CircleType = Value
    end
})

-- Triggerbot Logic
local LastActivationTime = tick()
local GuiInset = GuiService:GetGuiInset()
local TopbarOffset = GuiInset.Y

local CenterTriggerbotFOV = Instance.new("ScreenGui")
CenterTriggerbotFOV.Name = "CenterTriggerbotFOV"
CenterTriggerbotFOV.Parent = game.CoreGui
CenterTriggerbotFOV.IgnoreGuiInset = true

local MouseTriggerbotFOV = Instance.new("ScreenGui")
MouseTriggerbotFOV.Name = "MouseTriggerbotFOV"
MouseTriggerbotFOV.Parent = game.CoreGui
MouseTriggerbotFOV.IgnoreGuiInset = false

local function CreateCircle(name, filled, parent)
    local element = filled and Instance.new("Frame") or Instance.new("ImageLabel")
    element.Name = name
    element.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    element.AnchorPoint = Vector2.new(0.5, 0.5)
    
    if filled then
        element.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        element.BackgroundTransparency = 0.7
    else
        element.BackgroundTransparency = 1
        element.Image = "rbxassetid://0"
        local stroke = Instance.new("UIStroke")
        stroke.Thickness = 2
        stroke.Color = Color3.fromRGB(255, 255, 255)
        stroke.Parent = element
    end
    
    element.BorderSizePixel = 0
    element.Parent = parent
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.5, 0)
    corner.Parent = element
    
    return element
end

local CenterFilled = CreateCircle("CenterFilled", true, CenterTriggerbotFOV)
local CenterOutline = CreateCircle("CenterOutline", false, CenterTriggerbotFOV)
local MouseFilled = CreateCircle("MouseFilled", true, MouseTriggerbotFOV)
local MouseOutline = CreateCircle("MouseOutline", false, MouseTriggerbotFOV)

local function WallCheck(part)
    local origin = Camera.CFrame.Position
    local target = part.Position
    local direction = (target - origin).Unit
    local distance = (target - origin).Magnitude
    
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    
    local result = Workspace:Raycast(origin, direction * distance, params)
    if result then
        local hitPart = result.Instance
        local model = hitPart:FindFirstAncestorOfClass("Model")
        return not (model and Players:GetPlayerFromCharacter(model))
    end
    return true
end

local function UpdateTriggerbot()
    local isActive = getgenv().TriggerbotSettings.Enabled and 
        (getgenv().TriggerbotSettings.Mode == "Always" or 
         (getgenv().TriggerbotSettings.Mode == "Toggle" and getgenv().TriggerbotSettings.ToggleState))
    
    if not isActive then
        CenterFilled.Visible = false
        CenterOutline.Visible = false
        MouseFilled.Visible = false
        MouseOutline.Visible = false
        return
    end

    local targetPos, circlePos, activeFilled, activeOutline
    if getgenv().TriggerbotSettings.TargetMode == "Center of Screen" then
        activeFilled = CenterFilled
        activeOutline = CenterOutline
        MouseFilled.Visible = false
        MouseOutline.Visible = false
        targetPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        circlePos = UDim2.new(0.5, 0, 0.5, 0)
    else
        activeFilled = MouseFilled
        activeOutline = MouseOutline
        CenterFilled.Visible = false
        CenterOutline.Visible = false
        targetPos = Vector2.new(Mouse.X, Mouse.Y)
        circlePos = UDim2.new(0, Mouse.X, 0, Mouse.Y)
    end

    activeFilled.Position = circlePos
    activeOutline.Position = circlePos
    
    activeFilled.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    activeOutline.Size = UDim2.new(0, getgenv().TriggerbotSettings.Radius * 2, 0, getgenv().TriggerbotSettings.Radius * 2)
    
    activeFilled.Visible = getgenv().TriggerbotSettings.CircleVisible and getgenv().TriggerbotSettings.CircleType == "Filled"
    activeOutline.Visible = getgenv().TriggerbotSettings.CircleVisible and getgenv().TriggerbotSettings.CircleType == "Outline"
    
    local targetFound = false
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local screenPos, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - targetPos).Magnitude
                    if distance <= getgenv().TriggerbotSettings.Radius and not WallCheck(humanoidRootPart) then
                        targetFound = true
                        break
                    end
                end
            end
        end
    end
    
    if targetFound then
        if tick() - LastActivationTime >= getgenv().TriggerbotSettings.Delay then
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") and tool.Parent == character then
                    tool:Activate()
                    task.wait(0.1)
                    tool:Deactivate()
                    LastActivationTime = tick()
                end
            end
        end
        activeFilled.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        if activeOutline:FindFirstChild("UIStroke") then
            activeOutline.UIStroke.Color = Color3.fromRGB(0, 255, 0)
        end
    else
        activeFilled.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        if activeOutline:FindFirstChild("UIStroke") then
            activeOutline.UIStroke.Color = Color3.fromRGB(255, 0, 0)
        end
    end
end

RunService.RenderStepped:Connect(UpdateTriggerbot)

-- Rapid Fire
local RapidFireGroup = Tabs["Combat"]:AddRightGroupbox("Rapid Fire")

local RapidFireToggle = RapidFireGroup:AddToggle("RapidFireToggle", {
    Text = "Enable Rapid Fire",
    Default = false,
    Tooltip = "Hold m1 to shoot",
    Callback = function(Value)
        getgenv().RapidFireEnabled = Value
        Library:Notify("Rapid Fire " .. (Value and "включен" or "выключен"), 2)
    end
})

do
    local firing = false
    local debounce = false
    local minFireDelay = 0.05

    local function SAFEACTIVATE(tool)
        if not debounce and tool and tool:IsA("Tool") and getgenv().RapidFireEnabled then
            debounce = true
            pcall(function()
                tool:Activate()
            end)
            task.wait(minFireDelay)
            debounce = false
        end
    end

    local function fireLoop()
        while firing and getgenv().RapidFireEnabled do
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                SAFEACTIVATE(tool)
            end
            RunService.Heartbeat:Wait()
        end
    end

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 then
            firing = true
            if getgenv().RapidFireEnabled then
                fireLoop()
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            firing = false
        end
    end)

    local function setupCharacter(character)
        character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                child.Activated:Connect(function()
                    if firing and getgenv().RapidFireEnabled then
                        SAFEACTIVATE(child)
                    end
                end)
            end
        end)
    end

    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(character)
        character:WaitForChild("Humanoid")
        setupCharacter(character)
    end)
end

-- Pro Aim Settings
local ProAimGroup = Tabs["Combat"]:AddLeftGroupbox("Pro Aim Settings")

-- Глобальные переменные для Pro Aim
getgenv().ProAimSettings = {
    Enabled = false,
    Keybind = "F",
    ShowFOV = false,
    FOVSize = 300,
    Mode = "InFov", -- "InFov" или "Target"
    TargetPlayer = nil, -- Ник выбранного игрока для режима Target
    Distance = 10 -- Дальность закрепления
}

local isActive = false
local connection
local fovConnection
local targetPlayer = nil
local targetRootPart = nil
local targetESP = nil
local originalCFrame = nil
local wasAnchored = false
local wasCanCollide = false

-- Создание FOV круга
local fovCircle = Drawing and Drawing.new("Circle")
if fovCircle then
    fovCircle.Radius = getgenv().ProAimSettings.FOVSize
    fovCircle.Thickness = 2
    fovCircle.Color = Color3.fromRGB(255, 255, 255)
    fovCircle.Filled = false
    fovCircle.Visible = getgenv().ProAimSettings.ShowFOV
end

-- Функция создания ESP
local function createESP(part, color, name)
    if not part or not part.Parent then return nil end
    local esp = Instance.new("BoxHandleAdornment")
    esp.Name = name
    esp.Adornee = part
    esp.AlwaysOnTop = true
    esp.ZIndex = 10
    esp.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
    esp.Transparency = 0.5
    esp.Color3 = color
    esp.Parent = part
    return esp
end

-- Функция удаления ESP
local function clearESP()
    if targetESP then
        targetESP:Destroy()
        targetESP = nil
    end
end

-- Поиск корневой части
local function findRootPart(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart") or
                     character:FindFirstChild("Torso") or
                     character:FindFirstChild("UpperTorso") or
                     character:FindFirstChild("LowerTorso")
    if not rootPart then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") and string.find(part.Name:lower(), "torso") then
                rootPart = part
                break
            end
        end
    end
    return rootPart
end

-- Поиск ближайшего игрока к курсору
local function findClosestPlayerToCursor()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePosition = UserInputService:GetMouseLocation()
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local rootPart = findRootPart(player.Character)
            if rootPart then
                local screenPoint = Camera:WorldToViewportPoint(rootPart.Position)
                local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePosition).Magnitude
                if getgenv().ProAimSettings.Mode == "InFov" and distance <= getgenv().ProAimSettings.FOVSize or
                   getgenv().ProAimSettings.Mode == "Target" and player.Name == getgenv().ProAimSettings.TargetPlayer then
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Обновление позиции цели
local function updateTargetPosition()
    if not targetPlayer or not targetPlayer.Parent or not targetPlayer.Character or not targetPlayer.Character.Parent then
        targetPlayer = nil
        clearESP()
        return
    end
    
    if not LocalPlayer.Character or not findRootPart(LocalPlayer.Character) then return end
    
    targetRootPart = findRootPart(targetPlayer.Character)
    if not targetRootPart then
        targetPlayer = nil
        clearESP()
        return
    end
    
    if not originalCFrame then
        originalCFrame = targetRootPart.CFrame
    end
    
    if targetRootPart.Anchored then
        wasAnchored = true
        targetRootPart.Anchored = false
    else
        wasAnchored = false
    end
    
    if targetRootPart.CanCollide then
        wasCanCollide = true
        targetRootPart.CanCollide = false
    else
        wasCanCollide = false
    end
    
    local localPlayerRootPart = findRootPart(LocalPlayer.Character)
    local offsetPosition = localPlayerRootPart.Position + (localPlayerRootPart.CFrame.LookVector * getgenv().ProAimSettings.Distance)
    targetRootPart.CFrame = CFrame.new(offsetPosition)
    
    clearESP()
    targetESP = createESP(targetRootPart, Color3.new(1, 0, 0), "TargetESP")
end

-- Запуск Pro Aim
local function startProAim()
    if not isActive then
        isActive = true
        connection = RunService.Heartbeat:Connect(function()
            local closestPlayer = findClosestPlayerToCursor()
            
            if closestPlayer ~= targetPlayer then
                if targetPlayer and targetRootPart and originalCFrame then
                    targetRootPart.CFrame = originalCFrame
                    if wasAnchored then targetRootPart.Anchored = true end
                    if wasCanCollide then targetRootPart.CanCollide = true end
                    originalCFrame = nil
                end
                targetPlayer = closestPlayer
                clearESP()
            end
            
            if targetPlayer and targetPlayer.Character and targetPlayer.Character.Parent then
                updateTargetPosition()
            else
                if targetPlayer and targetRootPart and originalCFrame then
                    targetRootPart.CFrame = originalCFrame
                    if wasAnchored then targetRootPart.Anchored = true end
                    if wasCanCollide then targetRootPart.CanCollide = true end
                    originalCFrame = nil
                end
                targetPlayer = nil
                clearESP()
            end
        end)
    end
end

-- Остановка Pro Aim
local function stopProAim()
    if isActive then
        isActive = false
        if targetPlayer and targetRootPart and originalCFrame then
            targetRootPart.CFrame = originalCFrame
            if wasAnchored then targetRootPart.Anchored = true end
            if wasCanCollide then targetRootPart.CanCollide = true end
            originalCFrame = nil
        end
        targetPlayer = nil
        targetRootPart = nil
        clearESP()
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
end

-- Обновление FOV
if Drawing then
    fovConnection = RunService.Heartbeat:Connect(function()
        local mousePosition = UserInputService:GetMouseLocation()
        fovCircle.Position = mousePosition
        fovCircle.Radius = getgenv().ProAimSettings.FOVSize
        fovCircle.Visible = getgenv().ProAimSettings.ShowFOV and getgenv().ProAimSettings.Enabled
    end)
end

-- UI элементы для Pro Aim
local ProAimToggle = ProAimGroup:AddToggle("ProAimEnabled", {
    Text = "Enable Pro Aim",
    Default = getgenv().ProAimSettings.Enabled,
    Tooltip = "Enable/Disable Pro Aim",
    Callback = function(Value)
        getgenv().ProAimSettings.Enabled = Value
        if Value then
            startProAim()
        else
            stopProAim()
        end
    end
})

local ProAimKeybind = ProAimToggle:AddKeyPicker("ProAimKeybind", {
    Default = getgenv().ProAimSettings.Keybind,
    Mode = "Toggle",
    Text = "Pro Aim Key",
    NoUI = false,
    Callback = function(Value)
        if getgenv().ProAimSettings.Enabled then
            if isActive then
                stopProAim()
            else
                startProAim()
            end
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().ProAimSettings.Keybind = tostring(NewKey):lower()
    end
})

ProAimGroup:AddToggle("ProAimShowFOV", {
    Text = "Show FOV",
    Default = getgenv().ProAimSettings.ShowFOV,
    Tooltip = "Show/Hide the FOV circle",
    Callback = function(Value)
        getgenv().ProAimSettings.ShowFOV = Value
        if fovCircle then fovCircle.Visible = Value and getgenv().ProAimSettings.Enabled end
    end
})

ProAimGroup:AddSlider("ProAimFOVSize", {
    Text = "FOV Size",
    Default = getgenv().ProAimSettings.FOVSize,
    Min = 10,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        getgenv().ProAimSettings.FOVSize = Value
        if fovCircle then fovCircle.Radius = Value end
    end
})

ProAimGroup:AddSlider("ProAimDistance", {
    Text = "Target Distance",
    Default = getgenv().ProAimSettings.Distance,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Suffix = " studs",
    Callback = function(Value)
        getgenv().ProAimSettings.Distance = Value
    end
})

local ProAimModeDropdown = ProAimGroup:AddDropdown("ProAimMode", {
    Values = {"InFov", "Target"},
    Default = getgenv().ProAimSettings.Mode,
    Multi = false,
    Text = "Pro Aim Mode",
    Tooltip = "Select Pro Aim mode",
    Callback = function(Value)
        getgenv().ProAimSettings.Mode = Value
    end
})

-- Динамическое обновление списка игроков
local function updatePlayerList()
    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

local TargetPlayerDropdown = ProAimGroup:AddDropdown("ProAimTargetPlayer", {
    Values = updatePlayerList(),
    Default = getgenv().ProAimSettings.TargetPlayer,
    Multi = false,
    Text = "Target Player",
    Tooltip = "Select target player for Target mode",
    Callback = function(Value)
        getgenv().ProAimSettings.TargetPlayer = Value
    end
})

-- Обновление списка игроков при изменении состава
Players.PlayerAdded:Connect(function()
    TargetPlayerDropdown:SetValues(updatePlayerList())
end)

Players.PlayerRemoving:Connect(function(player)
    TargetPlayerDropdown:SetValues(updatePlayerList())
    if getgenv().ProAimSettings.TargetPlayer == player.Name then
        getgenv().ProAimSettings.TargetPlayer = nil
        TargetPlayerDropdown:SetValue(nil)
        stopProAim()
    end
end)

-- Проверка смерти цели
RunService.Heartbeat:Connect(function()
    if getgenv().ProAimSettings.Mode == "Target" and getgenv().ProAimSettings.TargetPlayer then
        local target = Players:FindFirstChild(getgenv().ProAimSettings.TargetPlayer)
        if target and target.Character then
            local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                stopProAim()
            end
        else
            stopProAim()
        end
    end
end)

-- Очистка при выходе игрока
LocalPlayer.AncestryChanged:Connect(function()
    if fovConnection then
        fovConnection:Disconnect()
        fovConnection = nil
    end
    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end
    stopProAim()
end)

-- Target Strafe Settings
local TargetStrafeGroup = Tabs["Combat"]:AddRightGroupbox("Target Strafe Settings")

-- Глобальные настройки для Target Strafe
getgenv().TargetStrafeSettings = {
    Enabled = false,
    Keybind = "G",
    TargetPlayer = nil,
    StrafeType = "Custom", -- "Custom", "Random", "Upwoake"
    CustomDistance = 10, -- Расстояние для Custom
    CustomSpeed = 5, -- Скорость для Custom
    CustomY = 0, -- Координата Y для Custom
    RandomDistance = 50, -- Расстояние для Random
    RandomSpeed = 5, -- Скорость для Random (новое)
    UpwoakeSpeed = 100, -- Скорость для Upwoake
    UpwoakeDistance = 10 -- Дальность для Upwoake
}

local strafeActive = false
local strafeConnection
local originalPosition -- Для сохранения позиции локального игрока

-- Функция для поиска корневой части персонажа
local function findRootPart(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart") or
                     character:FindFirstChild("Torso") or
                     character:FindFirstChild("UpperTorso") or
                     character:FindFirstChild("LowerTorso")
    if not rootPart then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") and string.find(part.Name:lower(), "torso") then
                rootPart = part
                break
            end
        end
    end
    return rootPart
end

-- Основная логика стрейфа
local function updateStrafe()
    if not strafeActive or not getgenv().TargetStrafeSettings.Enabled then return end
    
    local target = Players:FindFirstChild(getgenv().TargetStrafeSettings.TargetPlayer)
    if not target or not target.Character then return end
    
    local targetRoot = findRootPart(target.Character)
    local localRoot = findRootPart(LocalPlayer.Character)
    if not targetRoot or not localRoot then return end
    
    local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return end
    
    -- Сохраняем исходную позицию перед первым движением
    if not originalPosition then
        originalPosition = localRoot.Position
    end
    
    local time = tick()
    local angle = time * getgenv().TargetStrafeSettings.CustomSpeed -- Базовая скорость
    
    if getgenv().TargetStrafeSettings.StrafeType == "Custom" then
        local distance = getgenv().TargetStrafeSettings.CustomDistance
        local yOffset = getgenv().TargetStrafeSettings.CustomY
        local newPosition = targetRoot.Position + Vector3.new(
            math.cos(angle) * distance,
            yOffset,
            math.sin(angle) * distance
        )
        localRoot.CFrame = CFrame.new(newPosition, targetRoot.Position)
        
    elseif getgenv().TargetStrafeSettings.StrafeType == "Random" then
        local distance = getgenv().TargetStrafeSettings.RandomDistance
        local speed = getgenv().TargetStrafeSettings.RandomSpeed
        local randomAngle = math.random(0, 2 * math.pi)
        local newPosition = targetRoot.Position + Vector3.new(
            math.cos(randomAngle + time * speed) * distance,
            math.sin(time * speed) * 5, -- Небольшое колебание по Y
            math.sin(randomAngle + time * speed) * distance
        )
        localRoot.CFrame = CFrame.new(newPosition, targetRoot.Position)
        
    elseif getgenv().TargetStrafeSettings.StrafeType == "Upwoake" then
        local distance = getgenv().TargetStrafeSettings.UpwoakeDistance
        local speed = getgenv().TargetStrafeSettings.UpwoakeSpeed / 10 -- Уменьшаем делитель для более заметной скорости
        local height = math.abs(math.sin(time * speed)) * distance -- Полусфера вверх
        local newPosition = targetRoot.Position + Vector3.new(
            math.cos(angle * speed) * distance,
            height,
            math.sin(angle * speed) * distance
        )
        localRoot.CFrame = CFrame.new(newPosition, targetRoot.Position)
    end
end

-- Запуск стрейфа
local function startStrafe()
    if not strafeActive then
        strafeActive = true
        strafeConnection = RunService.Heartbeat:Connect(updateStrafe)
    end
end

-- Остановка стрейфа с возвратом на исходную позицию
local function stopStrafe()
    if strafeActive then
        strafeActive = false
        if strafeConnection then
            strafeConnection:Disconnect()
            strafeConnection = nil
        end
        -- Возвращаем локального игрока на исходную позицию
        local localRoot = findRootPart(LocalPlayer.Character)
        if localRoot and originalPosition then
            localRoot.CFrame = CFrame.new(originalPosition)
        end
        originalPosition = nil
    end
end

-- UI элементы для Target Strafe
local StrafeToggle = TargetStrafeGroup:AddToggle("StrafeEnabled", {
    Text = "Enable Strafe",
    Default = getgenv().TargetStrafeSettings.Enabled,
    Tooltip = "Enable/Disable Target Strafe",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.Enabled = Value
        if not Value then
            stopStrafe()
        end
    end
})

local StrafeKeybind = StrafeToggle:AddKeyPicker("StrafeKeybind", {
    Default = getgenv().TargetStrafeSettings.Keybind,
    Mode = "Toggle",
    Text = "Strafe Key",
    NoUI = false,
    Callback = function(Value)
        if getgenv().TargetStrafeSettings.Enabled then
            if strafeActive then
                stopStrafe()
            else
                startStrafe()
            end
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().TargetStrafeSettings.Keybind = tostring(NewKey):lower()
    end
})

-- Динамическое обновление списка игроков
local function updatePlayerList()
    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    return playerNames
end

local StrafeTargetDropdown = TargetStrafeGroup:AddDropdown("StrafeTarget", {
    Values = updatePlayerList(),
    Default = getgenv().TargetStrafeSettings.TargetPlayer,
    Multi = false,
    Text = "Target Player",
    Tooltip = "Select target player for strafe",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.TargetPlayer = Value
    end
})

-- Тип стрейфа
local StrafeTypeDropdown = TargetStrafeGroup:AddDropdown("StrafeType", {
    Values = {"Custom", "Random", "Upwoake"},
    Default = getgenv().TargetStrafeSettings.StrafeType,
    Multi = false,
    Text = "Strafe Type",
    Tooltip = "Select strafe movement type",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.StrafeType = Value
    end
})

-- Настройки для Custom
local CustomDistanceSlider = TargetStrafeGroup:AddSlider("CustomDistance", {
    Text = "Custom Distance",
    Default = getgenv().TargetStrafeSettings.CustomDistance,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Suffix = " studs",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.CustomDistance = Value
    end
})

local CustomSpeedSlider = TargetStrafeGroup:AddSlider("CustomSpeed", {
    Text = "Custom Speed",
    Default = getgenv().TargetStrafeSettings.CustomSpeed,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        getgenv().TargetStrafeSettings.CustomSpeed = Value
    end
})

local CustomYSlider = TargetStrafeGroup:AddSlider("CustomY", {
    Text = "Custom Y Offset",
    Default = getgenv().TargetStrafeSettings.CustomY,
    Min = -20,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Suffix = " studs",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.CustomY = Value
    end
})

-- Настройки для Random
local RandomDistanceSlider = TargetStrafeGroup:AddSlider("RandomDistance", {
    Text = "Random Distance",
    Default = getgenv().TargetStrafeSettings.RandomDistance,
    Min = 5,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Suffix = " studs",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.RandomDistance = Value
    end
})

local RandomSpeedSlider = TargetStrafeGroup:AddSlider("RandomSpeed", {
    Text = "Random Speed",
    Default = getgenv().TargetStrafeSettings.RandomSpeed,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        getgenv().TargetStrafeSettings.RandomSpeed = Value
    end
})

-- Настройки для Upwoake
local UpwoakeSpeedSlider = TargetStrafeGroup:AddSlider("UpwoakeSpeed", {
    Text = "Upwoake Speed",
    Default = getgenv().TargetStrafeSettings.UpwoakeSpeed,
    Min = 1,
    Max = 10000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        getgenv().TargetStrafeSettings.UpwoakeSpeed = Value
    end
})

local UpwoakeDistanceSlider = TargetStrafeGroup:AddSlider("UpwoakeDistance", {
    Text = "Upwoake Distance",
    Default = getgenv().TargetStrafeSettings.UpwoakeDistance,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Suffix = " studs",
    Callback = function(Value)
        getgenv().TargetStrafeSettings.UpwoakeDistance = Value
    end
})

-- Обработка событий для списка игроков
Players.PlayerAdded:Connect(function()
    StrafeTargetDropdown:SetValues(updatePlayerList())
end)

Players.PlayerRemoving:Connect(function(player)
    StrafeTargetDropdown:SetValues(updatePlayerList())
    if getgenv().TargetStrafeSettings.TargetPlayer == player.Name then
        getgenv().TargetStrafeSettings.TargetPlayer = nil
        StrafeTargetDropdown:SetValue(nil)
        stopStrafe()
    end
end)

-- Проверка смерти цели
RunService.Heartbeat:Connect(function()
    if getgenv().TargetStrafeSettings.Enabled and getgenv().TargetStrafeSettings.TargetPlayer then
        local target = Players:FindFirstChild(getgenv().TargetStrafeSettings.TargetPlayer)
        if target and target.Character then
            local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                stopStrafe()
            end
        else
            stopStrafe()
        end
    end
end)

-- Очистка при выходе игрока
LocalPlayer.AncestryChanged:Connect(function()
    stopStrafe()
end)

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local GuiService = game:GetService("GuiService")

-- Local variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

-- [Ваш существующий код Aimbot, Triggerbot, Rapid Fire, Pro Aim, Target Strafe остается без изменений до Movement] --

-- Speed Hack Settings
getgenv().SpeedHackSettings = {
    Enabled = false,
    Speed = 50,
    Keybind = "V"
}

-- Speed Hack Groupbox
local MovementGroup = Tabs["Movement"]:AddLeftGroupbox("Speed Hack Settings")

-- Speed Hack Logic
local speedHackConnection
local function updateSpeedHack(character)
    if not character then return end
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local humanoid = character:WaitForChild("Humanoid")
    local moveDirection = Vector3.new(0, 0, 0)

    if speedHackConnection then
        speedHackConnection:Disconnect()
    end

    speedHackConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if getgenv().SpeedHackSettings.Enabled then
            local move = humanoid.MoveDirection
            if move.Magnitude > 0 then
                moveDirection = move.Unit * getgenv().SpeedHackSettings.Speed
                rootPart.CFrame = rootPart.CFrame + (moveDirection * deltaTime)
            end
        end
    end)
end

-- Speed Hack UI Elements
local SpeedHackToggle = MovementGroup:AddToggle("SpeedHackEnabled", {
    Text = "Enable Speed Hack",
    Default = getgenv().SpeedHackSettings.Enabled,
    Tooltip = "Enable/Disable CFrame Speed Hack",
    Callback = function(Value)
        getgenv().SpeedHackSettings.Enabled = Value
        if Value then
            updateSpeedHack(LocalPlayer.Character)
        elseif speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
    end
})

local SpeedHackKeybind = SpeedHackToggle:AddKeyPicker("SpeedHackKeybind", {
    Default = getgenv().SpeedHackSettings.Keybind,
    Mode = "Toggle",
    Text = "Speed Hack Key",
    NoUI = false,
    Callback = function(Value)
        getgenv().SpeedHackSettings.Enabled = not getgenv().SpeedHackSettings.Enabled
        SpeedHackToggle:SetValue(getgenv().SpeedHackSettings.Enabled)
        Library:Notify({
            Title = "Speed Hack",
            Description = "Speed Hack " .. (getgenv().SpeedHackSettings.Enabled and "Enabled" or "Disabled"),
            Time = 2
        })
        if getgenv().SpeedHackSettings.Enabled then
            updateSpeedHack(LocalPlayer.Character)
        elseif speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
    end,
    ChangedCallback = function(NewKey)
        getgenv().SpeedHackSettings.Keybind = tostring(NewKey):lower()
    end
})

MovementGroup:AddInput("SpeedHackSpeed", {
    Default = tostring(getgenv().SpeedHackSettings.Speed),
    Numeric = true,
    Finished = true,
    Text = "Speed Value",
    Tooltip = "Set the speed value (studs per second)",
    Placeholder = "Enter speed...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0 then
            getgenv().SpeedHackSettings.Speed = numValue
            Library:Notify({
                Title = "Speed Hack",
                Description = "Speed set to " .. numValue,
                Time = 2
            })
        else
            Library:Notify({
                Title = "Speed Hack",
                Description = "Please enter a valid number!",
                Time = 2
            })
        end
    end
})

-- Handle character respawn
LocalPlayer.CharacterAdded:Connect(function(character)
    if getgenv().SpeedHackSettings.Enabled then
        updateSpeedHack(character)
    end
end)

-- Cleanup on player exit
LocalPlayer.AncestryChanged:Connect(function()
    if speedHackConnection then
        speedHackConnection:Disconnect()
        speedHackConnection = nil
    end
end)

-- Fly Hack Settings
local FlyHackGroup = Tabs["Movement"]:AddRightGroupbox("Fly Hack Settings")

-- Configuration for Fly Hack
getgenv().FlyHackSettings = {
    Enabled = false,           -- Global enable/disable (default: off)
    ToggleKey = "None",        -- Default toggle key (none)
    NormalSpeed = 25,          -- Regular flight speed
    Noclip = true,             -- Pass through objects (default: on)
    AntiRagdoll = true,        -- Prevent ragdoll effects
    Smoothness = 0.15          -- Movement smoothing (0-1)
}

-- State variables
local flying = false
local localPlayer = Players.LocalPlayer
local character, humanoid, rootPart
local bodyGyro, bodyVelocity, noclipConnection
local lastVelocity = Vector3.new()

-- Initialize character connection
local function initCharacter()
    character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    
    repeat task.wait() until character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart")
    humanoid = character:FindFirstChild("Humanoid")
    rootPart = character:FindFirstChild("HumanoidRootPart")
    
    if getgenv().FlyHackSettings.AntiRagdoll then
        humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
        humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
    end
    
    if flying then
        humanoid.PlatformStand = true
    end
end

-- Cleanup function
local function cleanup()
    if bodyGyro then 
        bodyGyro:Destroy() 
        bodyGyro = nil
    end
    if bodyVelocity then 
        bodyVelocity.Velocity = Vector3.new()
        bodyVelocity:Destroy() 
        bodyVelocity = nil
    end
    
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    
    if humanoid then
        humanoid.PlatformStand = false
        if getgenv().FlyHackSettings.AntiRagdoll then
            humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
        end
        task.spawn(function()
            task.wait(0.1)
            if rootPart then
                rootPart.Velocity = Vector3.new()
                rootPart.RotVelocity = Vector3.new()
            end
        end)
    end
    
    flying = false
    lastVelocity = Vector3.new()
end

-- Noclip implementation
local function enableNoclip()
    if not getgenv().FlyHackSettings.Noclip or noclipConnection then return end
    
    noclipConnection = RunService.Stepped:Connect(function()
        if character and flying then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end)
end

-- Disable Noclip
local function disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- Movement controller
local function flyController()
    if not getgenv().FlyHackSettings.Enabled or not rootPart then return end
    
    bodyGyro = Instance.new("BodyGyro")
    bodyVelocity = Instance.new("BodyVelocity")
    
    bodyGyro.P = 15000
    bodyGyro.D = 1000
    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bodyGyro.CFrame = rootPart.CFrame
    
    bodyVelocity.Velocity = Vector3.new()
    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    
    bodyGyro.Parent = rootPart
    bodyVelocity.Parent = rootPart
    humanoid.PlatformStand = true
    
    if getgenv().FlyHackSettings.Noclip then
        enableNoclip()
    end
    
    local flyConnection
    flyConnection = RunService.Heartbeat:Connect(function(delta)
        if not flying or not rootPart or not humanoid then
            flyConnection:Disconnect()
            cleanup()
            return
        end
        
        local camera = Workspace.CurrentCamera
        if not camera then return end
        
        local speed = getgenv().FlyHackSettings.NormalSpeed
        local moveDirection = Vector3.new()
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - camera.CFrame.LookVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - camera.CFrame.RightVector
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + camera.CFrame.RightVector
        end
        
        if moveDirection.Magnitude > 0 then
            moveDirection = moveDirection.Unit * speed
        end
        
        lastVelocity = lastVelocity:Lerp(moveDirection, getgenv().FlyHackSettings.Smoothness)
        bodyVelocity.Velocity = lastVelocity
        bodyGyro.CFrame = camera.CFrame
    end)
end

-- Toggle flight
local function toggleFlight()
    if not getgenv().FlyHackSettings.Enabled then return end
    
    flying = not flying
    
    if flying then
        flyController()
    else
        cleanup()
    end
end

-- UI Elements for Fly Hack
local FlyHackToggle = FlyHackGroup:AddToggle("FlyHackEnabled", {
    Text = "Enable Fly Hack",
    Default = getgenv().FlyHackSettings.Enabled,
    Tooltip = "Enable/Disable Fly Hack",
    Callback = function(Value)
        getgenv().FlyHackSettings.Enabled = Value
        if not Value and flying then
            toggleFlight() -- Выключаем полет, если был активен
        end
    end
})

local FlyHackKeybind = FlyHackToggle:AddKeyPicker("FlyHackKeybind", {
    Default = getgenv().FlyHackSettings.ToggleKey,
    Mode = "Toggle",
    Text = "Toggle Fly",
    NoUI = false,
    Callback = function(Value)
        toggleFlight()
    end,
    ChangedCallback = function(NewKey)
        getgenv().FlyHackSettings.ToggleKey = tostring(NewKey)
    end
})

FlyHackGroup:AddInput("FlyHackSpeed", {
    Default = tostring(getgenv().FlyHackSettings.NormalSpeed),
    Numeric = true,
    Finished = true,
    Text = "Fly Speed",
    Tooltip = "Set flight speed",
    Placeholder = "Enter speed...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0 then
            getgenv().FlyHackSettings.NormalSpeed = numValue
        end
    end
})

FlyHackGroup:AddToggle("FlyHackNoclip", {
    Text = "Enable Noclip",
    Default = getgenv().FlyHackSettings.Noclip,
    Tooltip = "Toggle noclip during flight",
    Callback = function(Value)
        getgenv().FlyHackSettings.Noclip = Value
        if not Value and flying then
            disableNoclip()
        elseif Value and flying then
            enableNoclip()
        end
    end
})

-- Initialize
initCharacter()

-- Character respawn handler
localPlayer.CharacterAdded:Connect(function(newChar)
    cleanup()
    initCharacter()
    if flying then
        task.wait(0.5)
        flyController()
    end
end)

-- Cleanup on player exit
localPlayer.AncestryChanged:Connect(function()
    cleanup()
end)

-- Target Desync Settings
local TargetDesyncGroup = Tabs["Combat"]:AddLeftGroupbox("Target Desync Settings")

-- Сервисы
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- Инициализация персонажа
local Char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HRP = Char:WaitForChild("HumanoidRootPart")
local Humanoid = Char:WaitForChild("Humanoid")
local Camera = Workspace.CurrentCamera

-- Настройки призрака
local GhostSettings = {
    TorsoSize = Vector3.new(2, 2, 1),
    HeadSize = Vector3.new(1, 1, 1),
    LimbSize = Vector3.new(1, 2, 1),
    Transparency = 0.1,
    PartColor = BrickColor.new("Light blue"),
    Material = Enum.Material.ForceField,
    HighlightFillColor = Color3.fromRGB(0, 170, 255),
    HighlightOutlineColor = Color3.fromRGB(0, 255, 255),
    HighlightFillTransparency = 0.8,
    HighlightOutlineTransparency = 0
}

-- Настройки Targetstrafe
getgenv().StrafeSettings = {
    Enabled = false,
    Keybind = "H",
    TargetPlayerName = nil, -- Будет обновляться через UI
    StrafeMode = "Upwoake", -- Режимы: "Custom", "Random", "Upwoake"
    StrafeRadius = 10,
    MinStrafeRadius = 5,
    SecondsPerRotation = 2,
    YOffset = 0,
    UpwoakeHeight = 5,
    UpwoakeRadius = 8,
    UpwoakeYSpeed = 1,
    DesyncAngles = {
        Enable = true,
        YawSpeed = 2,
        PitchSpeed = 1,
        RollSpeed = 0.5,
        MaxYawAngle = math.pi/4, -- 45°
        MaxPitchAngle = math.pi/6, -- 30°
        MaxRollAngle = math.pi/3 -- 60°
    },
    DesyncInterval = 0.0001
}

-- Переменные для режимов
local customStrafeAngle = 0
local upwoakeAngle = 0
local upwoakeYOffset = 0
local upwoakeYDirection = 1
local accumulatedTime = 0
local angleTime = 0

-- Рассчитываем скорость для Custom
local StrafeSpeed = (2 * math.pi) / getgenv().StrafeSettings.SecondsPerRotation

local teleportRandomConnection = nil
local followPart = nil
local ghostModel = nil

-- Создание FollowPart для камеры
local function createFollowPart()
    if followPart then
        followPart:Destroy()
    end
    local part = Instance.new("Part")
    part.Name = "FollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Parent = Workspace
    return part
end

-- Обновление FollowPart при смене персонажа
local function setupFollowPart(character)
    followPart = createFollowPart()
end

-- Создание модели призрака
local function createGhost()
    if ghostModel then
        ghostModel:Destroy()
    end
    local model = Instance.new("Model")
    model.Name = "GhostModel"
    model.Parent = Workspace

    local torso = Instance.new("Part")
    torso.Name = "Torso"
    torso.Size = GhostSettings.TorsoSize
    torso.Anchored = true
    torso.CanCollide = false
    torso.Transparency = GhostSettings.Transparency
    torso.BrickColor = GhostSettings.PartColor
    torso.Material = GhostSettings.Material
    torso.Parent = model

    local head = Instance.new("Part")
    head.Name = "Head"
    head.Size = GhostSettings.HeadSize
    head.Position = torso.Position + Vector3.new(0, 1.5, 0)
    head.Anchored = true
    head.CanCollide = false
    head.Transparency = GhostSettings.Transparency
    head.BrickColor = GhostSettings.PartColor
    head.Material = GhostSettings.Material
    head.Parent = model

    local leftArm = Instance.new("Part")
    leftArm.Name = "LeftArm"
    leftArm.Size = GhostSettings.LimbSize
    leftArm.Position = torso.Position + Vector3.new(-1.5, 0, 0)
    leftArm.Anchored = true
    leftArm.CanCollide = false
    leftArm.Transparency = GhostSettings.Transparency
    leftArm.BrickColor = GhostSettings.PartColor
    leftArm.Material = GhostSettings.Material
    leftArm.Parent = model

    local rightArm = Instance.new("Part")
    rightArm.Name = "RightArm"
    rightArm.Size = GhostSettings.LimbSize
    rightArm.Position = torso.Position + Vector3.new(1.5, 0, 0)
    rightArm.Anchored = true
    rightArm.CanCollide = false
    rightArm.Transparency = GhostSettings.Transparency
    rightArm.BrickColor = GhostSettings.PartColor
    rightArm.Material = GhostSettings.Material
    rightArm.Parent = model

    local leftLeg = Instance.new("Part")
    leftLeg.Name = "LeftLeg"
    leftLeg.Size = GhostSettings.LimbSize
    leftLeg.Position = torso.Position + Vector3.new(-0.5, -2, 0)
    leftLeg.Anchored = true
    leftLeg.CanCollide = false
    leftLeg.Transparency = GhostSettings.Transparency
    leftLeg.BrickColor = GhostSettings.PartColor
    leftLeg.Material = GhostSettings.Material
    leftLeg.Parent = model

    local rightLeg = Instance.new("Part")
    rightLeg.Name = "RightLeg"
    rightLeg.Size = GhostSettings.LimbSize
    rightLeg.Position = torso.Position + Vector3.new(0.5, -2, 0)
    rightLeg.Anchored = true
    rightLeg.CanCollide = false
    rightLeg.Transparency = GhostSettings.Transparency
    rightLeg.BrickColor = GhostSettings.PartColor
    rightLeg.Material = GhostSettings.Material
    rightLeg.Parent = model

    model.PrimaryPart = torso

    local highlight = Instance.new("Highlight")
    highlight.Name = "GhostHighlight"
    highlight.FillTransparency = GhostSettings.HighlightFillTransparency
    highlight.OutlineTransparency = GhostSettings.HighlightOutlineTransparency
    highlight.FillColor = GhostSettings.HighlightFillColor
    highlight.OutlineColor = GhostSettings.HighlightOutlineColor
    highlight.Parent = model

    return model
end

-- Функция для применения углов к CFrame
local function applyAngles(cframe, deltaTime)
    if not getgenv().StrafeSettings.DesyncAngles.Enable then
        return cframe
    end
    
    angleTime = angleTime + deltaTime
    
    local yaw = math.sin(angleTime * getgenv().StrafeSettings.DesyncAngles.YawSpeed) * getgenv().StrafeSettings.DesyncAngles.MaxYawAngle
    local pitch = math.cos(angleTime * getgenv().StrafeSettings.DesyncAngles.PitchSpeed * 0.7) * getgenv().StrafeSettings.DesyncAngles.MaxPitchAngle
    local roll = math.sin(angleTime * getgenv().StrafeSettings.DesyncAngles.RollSpeed * 0.5) * getgenv().StrafeSettings.DesyncAngles.MaxRollAngle
    
    return cframe * CFrame.Angles(pitch, yaw, roll)
end

-- Обновление призрака при смене персонажа
local function setupGhost(character)
    ghostModel = createGhost()
end

-- Функция проверки валидности цели
local function IsTargetValid(targetPlayer)
    if not targetPlayer or not targetPlayer.Parent then
        return false, "Target player not found"
    end
    if not targetPlayer.Character or not targetPlayer.Character.Parent then
        return false, "Target character not found"
    end
    local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetHRP or not targetHRP.Parent then
        return false, "Target HumanoidRootPart not found"
    end
    local targetHumanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not targetHumanoid or targetHumanoid.Health <= 0 then
        return false, "Target is dead or humanoid missing"
    end
    return true, targetHRP
end

local function TpToPos(deltaTime)
    if not Char or not HRP or not Humanoid or not Camera or not followPart or not ghostModel then
        Library:Notify({
            Title = "Target Desync",
            Description = "Missing required components",
            Time = 3
        })
        return
    end
    
    local originalCFrame = HRP.CFrame
    local targetPlayer = getgenv().StrafeSettings.TargetPlayerName and Players:FindFirstChild(getgenv().StrafeSettings.TargetPlayerName)
    local newCFrame

    local isValid, targetHRPOrError = IsTargetValid(targetPlayer)
    
    if isValid then
        local targetHRP = targetHRPOrError
        if not targetHRP or not targetHRP.Parent then
            Library:Notify({
                Title = "Target Desync",
                Description = "Target became invalid during update",
                Time = 3
            })
            ToggleRandomTeleport()
            return
        end
        
        if getgenv().StrafeSettings.StrafeMode == "Custom" then
            customStrafeAngle = customStrafeAngle + (StrafeSpeed * deltaTime)
            local offsetX = math.cos(customStrafeAngle) * getgenv().StrafeSettings.StrafeRadius
            local offsetZ = math.sin(customStrafeAngle) * getgenv().StrafeSettings.StrafeRadius
            local position = targetHRP.Position + Vector3.new(offsetX, getgenv().StrafeSettings.YOffset, offsetZ)
            newCFrame = CFrame.new(position, targetHRP.Position)
            
        elseif getgenv().StrafeSettings.StrafeMode == "Random" then
            local randomAngle = math.random() * 2 * math.pi
            local randomDistance = math.random(getgenv().StrafeSettings.MinStrafeRadius, getgenv().StrafeSettings.StrafeRadius)
            local offsetX = math.cos(randomAngle) * randomDistance
            local offsetZ = math.sin(randomAngle) * randomDistance
            local position = targetHRP.Position + Vector3.new(offsetX, getgenv().StrafeSettings.YOffset, offsetZ)
            newCFrame = CFrame.new(position, targetHRP.Position)
            
        elseif getgenv().StrafeSettings.StrafeMode == "Upwoake" then
            upwoakeAngle = upwoakeAngle + (StrafeSpeed * deltaTime)
            upwoakeYOffset = upwoakeYOffset + (getgenv().StrafeSettings.UpwoakeYSpeed * deltaTime * upwoakeYDirection)
            
            if upwoakeYOffset > getgenv().StrafeSettings.UpwoakeHeight then
                upwoakeYOffset = getgenv().StrafeSettings.UpwoakeHeight
                upwoakeYDirection = -1
            elseif upwoakeYOffset < 0 then
                upwoakeYOffset = 0
                upwoakeYDirection = 1
            end
            
            local radius = getgenv().StrafeSettings.UpwoakeRadius * math.sqrt(1 - (upwoakeYOffset/getgenv().StrafeSettings.UpwoakeHeight)^2)
            local offsetX = math.cos(upwoakeAngle) * radius
            local offsetZ = math.sin(upwoakeAngle) * radius
            local position = targetHRP.Position + Vector3.new(offsetX, upwoakeYOffset, offsetZ)
            newCFrame = CFrame.new(position, targetHRP.Position)
        end
    else
        local offsetX = math.random(-10, 10)
        local offsetZ = math.random(-10, 10)
        newCFrame = originalCFrame + Vector3.new(offsetX, 0, offsetZ)
        if getgenv().StrafeSettings.TargetPlayerName then
            Library:Notify({
                Title = "Target Desync",
                Description = "Target invalid: " .. tostring(targetHRPOrError) .. ". Using random offset.",
                Time = 3
            })
        end
    end

    newCFrame = applyAngles(newCFrame, deltaTime)

    if followPart and followPart.Parent then
        followPart.CFrame = originalCFrame + Vector3.new(0, 1.5, 0)
    else
        setupFollowPart(Char)
        followPart.CFrame = originalCFrame + Vector3.new(0, 1.5, 0)
    end
    Camera.CameraSubject = followPart

    if ghostModel and ghostModel.PrimaryPart then
        ghostModel:SetPrimaryPartCFrame(newCFrame)
        HRP.CFrame = newCFrame
        RunService.RenderStepped:Wait()
        HRP.CFrame = originalCFrame
    else
        Library:Notify({
            Title = "Target Desync",
            Description = "Missing ghost model or primary part",
            Time = 3
        })
    end

    Camera.CameraSubject = Humanoid
end

function ToggleRandomTeleport()
    if not getgenv().StrafeSettings.Enabled then
        Library:Notify({
            Title = "Target Desync",
            Description = "Please enable Target Desync first!",
            Time = 3
        })
        return
    end

    -- Отладка: выводим текущую цель
    print("Attempting to toggle desync. TargetPlayerName:", getgenv().StrafeSettings.TargetPlayerName, "Type:", type(getgenv().StrafeSettings.TargetPlayerName))

    -- Проверка, что TargetPlayerName — строка
    if getgenv().StrafeSettings.TargetPlayerName and type(getgenv().StrafeSettings.TargetPlayerName) ~= "string" then
        Library:Notify({
            Title = "Target Desync",
            Description = "Invalid target name type: " .. type(getgenv().StrafeSettings.TargetPlayerName),
            Time = 3
        })
        getgenv().StrafeSettings.TargetPlayerName = nil
        DesyncTargetDropdown:SetValue(nil)
        return
    end

    local targetPlayer = getgenv().StrafeSettings.TargetPlayerName and Players:FindFirstChild(getgenv().StrafeSettings.TargetPlayerName)
    
    -- Проверка на nil перед вызовом IsTargetValid
    if getgenv().StrafeSettings.TargetPlayerName and not targetPlayer then
        Library:Notify({
            Title = "Target Desync",
            Description = "Player " .. tostring(getgenv().StrafeSettings.TargetPlayerName) .. " not found in Players list",
            Time = 3
        })
        getgenv().StrafeSettings.TargetPlayerName = nil
        DesyncTargetDropdown:SetValue(nil)
        return
    end

    local isValid, errorMsg = IsTargetValid(targetPlayer)
    
    if not isValid and getgenv().StrafeSettings.TargetPlayerName then
        Library:Notify({
            Title = "Target Desync",
            Description = "Cannot enable: " .. tostring(errorMsg),
            Time = 3
        })
        getgenv().StrafeSettings.TargetPlayerName = nil
        DesyncTargetDropdown:SetValue(nil)
        return
    end

    if teleportRandomConnection then
        teleportRandomConnection:Disconnect()
        teleportRandomConnection = nil
        if followPart then
            followPart:Destroy()
            followPart = nil
        end
        if ghostModel then
            ghostModel:Destroy()
            ghostModel = nil
        end
        Library:Notify({
            Title = "Target Desync",
            Description = "Desync Disabled",
            Time = 3
        })
    else
        if not targetPlayer then
            Library:Notify({
                Title = "Target Desync",
                Description = "No target selected. Using random offset.",
                Time = 3
            })
        end
        setupFollowPart(Char)
        setupGhost(Char)
        accumulatedTime = 0
        upwoakeYOffset = 0
        angleTime = 0
        StrafeSpeed = (2 * math.pi) / getgenv().StrafeSettings.SecondsPerRotation
        teleportRandomConnection = RunService.Heartbeat:Connect(function(deltaTime)
            if HRP.Velocity.Magnitude > 0 then
                accumulatedTime = accumulatedTime + deltaTime
                if accumulatedTime >= getgenv().StrafeSettings.DesyncInterval then
                    TpToPos(deltaTime)
                    accumulatedTime = accumulatedTime - getgenv().StrafeSettings.DesyncInterval
                end
            end
        end)
        Library:Notify({
            Title = "Target Desync",
            Description = "Desync Enabled in mode: " .. getgenv().StrafeSettings.StrafeMode,
            Time = 3
        })
    end
end

-- Обработчик появления нового персонажа
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Char = newCharacter
    HRP = Char:WaitForChild("HumanoidRootPart")
    Humanoid = Char:WaitForChild("Humanoid")
    if teleportRandomConnection then
        setupFollowPart(newCharacter)
        setupGhost(newCharacter)
    end
end)

-- UI Elements for Target Desync
local DesyncToggle = TargetDesyncGroup:AddToggle("DesyncEnabled", {
    Text = "Enable Target Desync",
    Default = getgenv().StrafeSettings.Enabled,
    Tooltip = "Enable/Disable Target Desync",
    Callback = function(Value)
        getgenv().StrafeSettings.Enabled = Value
        if not Value and teleportRandomConnection then
            ToggleRandomTeleport()
        end
    end
})

local DesyncKeybind = DesyncToggle:AddKeyPicker("DesyncKeybind", {
    Default = getgenv().StrafeSettings.Keybind,
    Mode = "Toggle",
    Text = "Desync Key",
    NoUI = false,
    Callback = function(Value)
        ToggleRandomTeleport()
    end,
    ChangedCallback = function(NewKey)
        getgenv().StrafeSettings.Keybind = tostring(NewKey):lower()
    end
})

TargetDesyncGroup:AddDropdown("DesyncMode", {
    Values = {"Custom", "Random", "Upwoake"},
    Default = getgenv().StrafeSettings.StrafeMode,
    Multi = false,
    Text = "Desync Mode",
    Tooltip = "Select desync movement type",
    Callback = function(Value)
        getgenv().StrafeSettings.StrafeMode = Value
        Library:Notify({
            Title = "Target Desync",
            Description = "Mode changed to " .. Value,
            Time = 3
        })
    end
})

-- Выпадающий список для выбора цели
-- Выпадающий список для выбора цели
local DesyncTargetDropdown = TargetDesyncGroup:AddDropdown("DesyncTarget", {
    SpecialType = "Player",
    Text = "Target Player",
    Tooltip = "Select target player for desync",
    Multi = false,
    AllowNull = true,
    ExcludeLocalPlayer = true,
    Callback = function(Value)
        -- Отладка: выводим тип и значение Value
        print("Dropdown Value:", Value, "Type:", type(Value))
        
        -- Если Value — это объект Player, берём его имя
        if typeof(Value) == "Instance" and Value:IsA("Player") then
            getgenv().StrafeSettings.TargetPlayerName = Value.Name
            Library:Notify({
                Title = "Target Desync",
                Description = "Target set to " .. Value.Name,
                Time = 3
            })
        elseif type(Value) == "string" then
            getgenv().StrafeSettings.TargetPlayerName = Value
            Library:Notify({
                Title = "Target Desync",
                Description = "Target set to " .. Value,
                Time = 3
            })
        else
            getgenv().StrafeSettings.TargetPlayerName = nil
            Library:Notify({
                Title = "Target Desync",
                Description = "Target cleared",
                Time = 3
            })
        end
    end
})

-- Strafe settings
TargetDesyncGroup:AddInput("StrafeRadius", {
    Default = tostring(getgenv().StrafeSettings.StrafeRadius),
    Numeric = true,
    Finished = true,
    Text = "Strafe Radius",
    Tooltip = "Radius for Custom/Random modes (studs)",
    Placeholder = "Enter radius...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 1 then
            getgenv().StrafeSettings.StrafeRadius = numValue
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number >= 1!",
                Time = 2
            })
        end
    end
})

TargetDesyncGroup:AddInput("MinStrafeRadius", {
    Default = tostring(getgenv().StrafeSettings.MinStrafeRadius),
    Numeric = true,
    Finished = true,
    Text = "Min Strafe Radius",
    Tooltip = "Minimum radius for Random mode (studs)",
    Placeholder = "Enter min radius...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 1 then
            getgenv().StrafeSettings.MinStrafeRadius = numValue
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number >= 1!",
                Time = 2
            })
        end
    end
})

TargetDesyncGroup:AddInput("SecondsPerRotation", {
    Default = tostring(getgenv().StrafeSettings.SecondsPerRotation),
    Numeric = true,
    Finished = true,
    Text = "Seconds per Rotation",
    Tooltip = "Time for one full rotation (seconds)",
    Placeholder = "Enter seconds...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue > 0 then
            getgenv().StrafeSettings.SecondsPerRotation = numValue
            StrafeSpeed = (2 * math.pi) / getgenv().StrafeSettings.SecondsPerRotation
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number > 0!",
                Time = 2
            })
        end
    end
})

TargetDesyncGroup:AddInput("YOffset", {
    Default = tostring(getgenv().StrafeSettings.YOffset),
    Numeric = true,
    Finished = true,
    Text = "Y Offset",
    Tooltip = "Vertical offset for Custom/Random modes (studs)",
    Placeholder = "Enter offset...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue then
            getgenv().StrafeSettings.YOffset = numValue
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number!",
                Time = 2
            })
        end
    end
})

TargetDesyncGroup:AddInput("UpwoakeHeight", {
    Default = tostring(getgenv().StrafeSettings.UpwoakeHeight),
    Numeric = true,
    Finished = true,
    Text = "Upwoake Height",
    Tooltip = "Max height for Upwoake mode (studs)",
    Placeholder = "Enter height...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0 then
            getgenv().StrafeSettings.UpwoakeHeight = numValue
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number >= 0!",
                Time = 2
            })
        end
    end
})

TargetDesyncGroup:AddInput("UpwoakeRadius", {
    Default = tostring(getgenv().StrafeSettings.UpwoakeRadius),
    Numeric = true,
    Finished = true,
    Text = "Upwoake Radius",
    Tooltip = "Radius for Upwoake mode (studs)",
    Placeholder = "Enter radius...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 1 then
            getgenv().StrafeSettings.UpwoakeRadius = numValue
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number >= 1!",
                Time = 2
            })
        end
    end
})

TargetDesyncGroup:AddInput("UpwoakeYSpeed", {
    Default = tostring(getgenv().StrafeSettings.UpwoakeYSpeed),
    Numeric = true,
    Finished = true,
    Text = "Upwoake Y Speed",
    Tooltip = "Vertical speed for Upwoake mode",
    Placeholder = "Enter speed...",
    Callback = function(Value)
        local numValue = tonumber(Value)
        if numValue and numValue >= 0 then
            getgenv().StrafeSettings.UpwoakeYSpeed = numValue
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Please enter a valid number >= 0!",
                Time = 2
            })
        end
    end
})

-- Desync Angles settings
local DesyncAnglesToggle = TargetDesyncGroup:AddToggle("DesyncAnglesEnabled", {
    Text = "Enable Desync Angles",
    Default = getgenv().StrafeSettings.DesyncAngles.Enable,
    Tooltip = "Enable angle manipulation for desync",
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.Enable = Value
        Library:Notify({
            Title = "Target Desync",
            Description = "Desync Angles: " .. (Value and "Enabled" or "Disabled"),
            Time = 3
        })
    end
})

TargetDesyncGroup:AddSlider("YawSpeed", {
    Text = "Yaw Speed",
    Default = getgenv().StrafeSettings.DesyncAngles.YawSpeed,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.YawSpeed = Value
        Library:Notify({
            Title = "Target Desync",
            Description = "Yaw Speed set to: " .. Value,
            Time = 2
        })
    end
})

TargetDesyncGroup:AddSlider("PitchSpeed", {
    Text = "Pitch Speed",
    Default = getgenv().StrafeSettings.DesyncAngles.PitchSpeed,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.PitchSpeed = Value
        Library:Notify({
            Title = "Target Desync",
            Description = "Pitch Speed set to: " .. Value,
            Time = 2
        })
    end
})

TargetDesyncGroup:AddSlider("RollSpeed", {
    Text = "Roll Speed",
    Default = getgenv().StrafeSettings.DesyncAngles.RollSpeed,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.RollSpeed = Value
        Library:Notify({
            Title = "Target Desync",
            Description = "Roll Speed set to: " .. Value,
            Time = 2
        })
    end
})

TargetDesyncGroup:AddSlider("MaxYawAngle", {
    Text = "Max Yaw Angle",
    Default = math.deg(getgenv().StrafeSettings.DesyncAngles.MaxYawAngle),
    Min = 0,
    Max = 180,
    Rounding = 0,
    Suffix = "°",
    Compact = false,
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.MaxYawAngle = math.rad(Value)
        Library:Notify({
            Title = "Target Desync",
            Description = "Max Yaw Angle set to: " .. Value .. "°",
            Time = 2
        })
    end
})

TargetDesyncGroup:AddSlider("MaxPitchAngle", {
    Text = "Max Pitch Angle",
    Default = math.deg(getgenv().StrafeSettings.DesyncAngles.MaxPitchAngle),
    Min = 0,
    Max = 180,
    Rounding = 0,
    Suffix = "°",
    Compact = false,
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.MaxPitchAngle = math.rad(Value)
        Library:Notify({
            Title = "Target Desync",
            Description = "Max Pitch Angle set to: " .. Value .. "°",
            Time = 2
        })
    end
})

TargetDesyncGroup:AddSlider("MaxRollAngle", {
    Text = "Max Roll Angle",
    Default = math.deg(getgenv().StrafeSettings.DesyncAngles.MaxRollAngle),
    Min = 0,
    Max = 180,
    Rounding = 0,
    Suffix = "°",
    Compact = false,
    Callback = function(Value)
        getgenv().StrafeSettings.DesyncAngles.MaxRollAngle = math.rad(Value)
        Library:Notify({
            Title = "Target Desync",
            Description = "Max Roll Angle set to: " .. Value .. "°",
            Time = 2
        })
    end
})

-- Target death check and cleanup
RunService.Heartbeat:Connect(function()
    if getgenv().StrafeSettings.Enabled and teleportRandomConnection then
        local targetPlayer = getgenv().StrafeSettings.TargetPlayerName and Players:FindFirstChild(getgenv().StrafeSettings.TargetPlayerName)
        local isValid, errorMsg = IsTargetValid(targetPlayer)
        if not isValid then
            ToggleRandomTeleport()
            if getgenv().StrafeSettings.TargetPlayerName then
                Library:Notify({
                    Title = "Target Desync",
                    Description = "Desync disabled: " .. tostring(errorMsg),
                    Time = 3
                })
                getgenv().StrafeSettings.TargetPlayerName = nil
                DesyncTargetDropdown:SetValue(nil)
            end
        end
    end
end)

-- Cleanup on player exit
LocalPlayer.AncestryChanged:Connect(function()
    if teleportRandomConnection then
        ToggleRandomTeleport()
    end
end)

-- Команды для управления в чате
LocalPlayer.Chatted:Connect(function(message)
    local args = message:lower():split(" ")
    
    if args[1] == "/mode" and args[2] then
        local newMode = args[2]:gsub("^%l", string.upper)
        if newMode == "Custom" or newMode == "Random" or newMode == "Upwoake" then
            getgenv().StrafeSettings.StrafeMode = newMode
            Library:Notify({
                Title = "Target Desync",
                Description = "Mode changed to " .. newMode,
                Time = 3
            })
        else
            Library:Notify({
                Title = "Target Desync",
                Description = "Invalid mode! Use Custom, Random, or Upwoake",
                Time = 3
            })
        end
        
    elseif args[1] == "/angles" then
        getgenv().StrafeSettings.DesyncAngles.Enable = not getgenv().StrafeSettings.DesyncAngles.Enable
        Library:Notify({
            Title = "Target Desync",
            Description = "Desync Angles: " .. (getgenv().StrafeSettings.DesyncAngles.Enable and "Enabled" or "Disabled"),
            Time = 3
        })
        DesyncAnglesToggle:SetValue(getgenv().StrafeSettings.DesyncAngles.Enable)
        
    elseif args[1] == "/setangle" and args[2] and args[3] then
        local angleType = args[2]:lower()
        local value = tonumber(args[3])
        
        if angleType == "yaw" then
            getgenv().StrafeSettings.DesyncAngles.MaxYawAngle = math.rad(value)
            Library:Notify({
                Title = "Target Desync",
                Description = "Max Yaw Angle set to: " .. value .. "°",
                Time = 2
            })
        elseif angleType == "pitch" then
            getgenv().StrafeSettings.DesyncAngles.MaxPitchAngle = math.rad(value)
            Library:Notify({
                Title = "Target Desync",
                Description = "Max Pitch Angle set to: " .. value .. "°",
                Time = 2
            })
        elseif angleType == "roll" then
            getgenv().StrafeSettings.DesyncAngles.MaxRollAngle = math.rad(value)
            Library:Notify({
                Title = "Target Desync",
                Description = "Max Roll Angle set to: " .. value .. "°",
                Time = 2
            })
        end
        
    elseif args[1] == "/setspeed" and args[2] and args[3] then
        local speedType = args[2]:lower()
        local value = tonumber(args[3])
        
        if speedType == "yaw" then
            getgenv().StrafeSettings.DesyncAngles.YawSpeed = value
            Library:Notify({
                Title = "Target Desync",
                Description = "Yaw Speed set to: " .. value,
                Time = 2
            })
        elseif speedType == "pitch" then
            getgenv().StrafeSettings.DesyncAngles.PitchSpeed = value
            Library:Notify({
                Title = "Target Desync",
                Description = "Pitch Speed set to: " .. value,
                Time = 2
            })
        elseif speedType == "roll" then
            getgenv().StrafeSettings.DesyncAngles.RollSpeed = value
            Library:Notify({
                Title = "Target Desync",
                Description = "Roll Speed set to: " .. value,
                Time = 2
            })
        end
    end
end)

-- Инициализация
if Char then
    setupFollowPart(Char)
    setupGhost(Char)
end

-- Setup ThemeManager and SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("ClickGUI")
SaveManager:SetFolder("ClickGUI/settings")

SaveManager:BuildConfigSection(Tabs["HUD"])
ThemeManager:ApplyToTab(Tabs["HUD"])

-- Show the UI
Library:Toggle(true)
